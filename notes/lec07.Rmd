---
title: "FE8828 Programming Web Applications in Finance"
subtitle: "<sub> Week 3 <br> Data, visualization, and web: part 2 </sub>"
author: "Dr. Yang Ye <sub> <Email:yy@runchee.com> </sub>"
date: "Nov 16, 2017"
# runtime: shiny
---

<style type="text/css">

code.r{ /* Code block */
    font-size: 18px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 15px;
}
</style>

```{r setup, include=FALSE}
library(tidyverse)
library(shiny)
library(lubridate)
library(bizdays)
library(fOptions)
library(ggplot2)
knitr::opts_chunk$set(echo = FALSE, fig.align="center", collapse = TRUE, cache = T)
chunk <- "```"
inline <- function(x = "") paste0("`` `r ", x, "` ``")
bank <- read.csv("https://goo.gl/PBQnBt", sep = ";")
```

# Lecture 7: Data 2

# Joins

```{r, echo = FALSE, out.width = "75%"}
knitr::include_graphics("imgs/join_today_header_image.jpg")
```

# left_join / right_join / anti_join / full_join

| Position_id | Buy/Sell | Quantity | Risk Factor |

Positions are additive (to close a position, we won't change the original position but to do a new reverse trade).
Suppose we have two days of position data.

    new_data <- filter(position, date == new_date)
    old_data <- filter(position, date == old_date)

In order to find the new positions. We will use:

    anti_join(new_data, old_data, by = "position_id") # order matters, new_data needs to be placed first.

In order to find old positions, we will use:

    inner_join(new_data, old_data, by = "position_id") # regardless order, new_data needs to be in front of old_data.
    left_join(old_data, new_data, by = "position_id") # produce the same result
    right_join(new_data, old_data, by = "position_id") # produce the same result

# left_join/right_join
Can be used to do mapping table (aka. vlookup)

Table a:

    | type_code | type_name |
    | 1         | orange    |
    | 2         | banana    |

Table b:

    | type_code | quantity | customer_id |
    | 1         | 1        | A           |
    | 2         | 3        | B           |
    | 3         | 4        | C           |
    | 2         | 2        | D           |
    | 1         | 6        | B           |

Table c:

    | customer_id | customer_phone |
    | A           | +123           |
    | B           | +456           |
    | C           | +789           |

left_join(b, a, by = "type_code") %>% left_join(c, by = "customer_id")

    | type_code | quantity | customer_id | type_name | customer_phone |
    | 1         | 1        | A           | orange    | +123           |
    | 2         | 3        | B           | banana    | +456           |
    | 3         | 4        | C           | NA        | +789           |
    | 2         | 2        | D           | banana    | NA             |
    | 1         | 6        | B           | orange    | +456           |

Join can be multiple types

## full_join
Find all combinations between table a and b.

# all possible combination 
x <- full_join(distinct(bank, job) %>% mutate(x = 1), distinct(bank, education) %>% mutate(x = 1)) %>% select(-x)
y <- distinct(bank, job, education)

anti_join(x, y)
anti_join(y, x)

nrow(x)
nrow(y)

# Joins is a set operation

- full_join is `*`
- anti_join is `-`
- inner_joins is `-`, `/`
- left_join/right_join is either just the same, or `*`, `/`. 

# bind_rows
- bind_rows is the `+` operator for data frames.

```{r, echo = T}
# add empty data frame is the same.
bind_rows(data.frame(a = 3:4), data.frame())
bind_rows(data.frame(), data.frame(a = 3:4))
```

I usually use bind_rows to collect results. For example,

    new_positions <- data.frame()
    closed_positions <- data.frame()

    for (i in length(dates)-1) {
      old_date <- dates[i]
      new_date <- dates[i+1]

      new_data <- filter(position, date == new_date)
      old_data <- filter(position, date == old_date)

      new_positions <- bind_rows(new_positions,
                                 anti_join(new_data, old_data, by = "position_id"))
    }

    # new_positions contains all new positions on day 1

# bind_cols
- bind_cols is to extend the data frame in width.

Use cases
- It's a lazyman's `left_join` or `select`
- It does the copy
- I usually find it useful to generate data frame for reports.

```{r, echo = T}
dt1 <- bind_cols(select(bank, job), select(bank, education))
dt1[1:3,]
dt2 <- bind_cols(dt1, dt1)
dt2[1:3,]
```

# Plot
data.model <- select(bank, job, education) %>% mutate(job = factor(job), education = factor(education))
plot(data.model)

bank.num <- model.matrix(~ . - 1, data.model)
data.model$cl <- kmeans(bank.num, 4)$cluster

plot(data.model)

# Plot
with(data.model, plot(job, education, type = 'n'))
with(data.model, text(job, education, education, col=cl))

group_by(bank, cl) %>% summarise(n = n())

# group_by
bank1 <- group_by(bank, age) %>%
  summarise(balance_mean = mean(balance),
            count = n(),
            default_count = sum(ifelse(default == "no", 0, 1)))

mutate with group_by
```{r, echo = T}
group_by(data.frame(a = 1:10), quartile = ntile(a, 2)) %>% mutate(b = a / sum(a))
```
summarise with group_by
```{r, echo = T}
group_by(data.frame(a = 1:10), quartile = ntile(a, 2)) %>% summarise(b = sum(a))
```

group_by is a like folding a paper without tearing it later.
summarise will tear the paper.

## If combined with ggplot, to be learnt in next session
ggplot(bank1, aes(x = age, y = balance_mean)) +
  geom_point(aes(size = count), alpha = 1/4, color = "red") +
  geom_point(aes(size = default_count), alpha = 1/3, color = "blue") +
  geom_smooth(se = F)

sum(x, na.rm = T)

# summarise functions
## mean(x), but median(x)
mean(age[balance > 0])
mean(age[balance < 0])
# sd(x), IQR(x), mad(x)
sd(distance)
# min(x), quantile(x, 0.25), max(x)
# n(): count / n_distinct()
# first(x), nth(x, 2), last(x)
# count for condition
sum(balance < 500)): TRUE => 1, FALSE => 0
sum(x > 10), mean(y == 0)

I often forgot there are existing functions that resort to longer versions.

# group filter
Find the maximum and minimum balance on each age.
bank %>% 
  group_by(age) %>%
  filter(min_rank(balance) == 1 | min_rank(desc(balance)) == 1) %>%
  arrange(age, balance)

Find the big age group
bank %>% 
  group_by(age %/% 10) %>%
  filter(n()/nrow(bank) > 0.2) %>%
  arrange(age)

ungroup() removes strata, restores the data frame back to entire rows.

chicago <- mutate(baml, year = as.POSIXlt(date)$year + 1900)
> summarize(years, pm25 = mean(pm25, na.rm = TRUE), 
+           o3 = max(o3tmean2, na.rm = TRUE), 
+           no2 = median(no2tmean2, na.rm = TRUE))

> qq <- quantile(chicago$pm25, seq(0, 1, 0.2), na.rm = TRUE)
> chicago <- mutate(chicago, pm25.quint = cut(pm25, qq))

> quint <- group_by(chicago, pm25.quint)
Finally, we can compute the mean of o3 and no2 within quintiles of pm25.

> summarize(quint, o3 = mean(o3tmean2, na.rm = TRUE), 
+           no2 = mean(no2tmean2, na.rm = TRUE))

# mutate with style

    ungroup() %>%
    mutate(nnn = 1:n()) %>%
    mutate(x = tryCatch({
        as.Date(x)
    })

group_by/rowwise/ungroup

# grouped or ungrouped
    
    ungroup(df) %>% mutate( x = ifelse( x == "ABC", "is ABC", "not ABC" ) )
    group_by(x) %>% summarise( cc = count(x) )

# summarise without a group_by
Just cover entire dataset.

    summarise( x = sum(ifelse( x == "ABC", 1, 0 ) )
  min()
  max()
  n = n()
  mean()

# rowwise
Use if. ifelse is restrictive that it only output the same type as the input.

    rowwise(df) %>% mutate( x = { if ( x == "ABC" ) { "is ABC" } else { "not ABC" }  } )

# summarise
 example: how to get sub-total and total.

# do
do. with an index column and do the analysis for the rest.

```{r, echo = T}
library(ggplot2)
library(reshape2)

biorhythm <- function(dob, target = Sys.Date()) {
  dob <- as.Date(dob)
  target <- as.Date(target)
  t <- round(as.numeric(difftime(target, dob)))
  days <- (t - 14) : (t + 14)
  period <- data.frame(Date = seq.Date(from = target - 15, by = 1, length.out = 29),
                       Physical = sin (2 * pi * days / 23) * 100, 
                       Emotional = sin (2 * pi * days / 28) * 100, 
                       Intellectual = sin (2 * pi * days / 33) * 100)
  period <- melt(period, id.vars = "Date", variable.name = "Biorhythm", value.name = "Percentage")
  ggplot(period, aes(x = Date, y = Percentage, col = Biorhythm)) + geom_line() +  
    ggtitle(paste("DoB:", format(dob, "%d %B %Y"))) + 
    geom_vline(xintercept = as.numeric(target))
}

biorhythm("1969-09-12", "2017-03-30")
biorhythm("1981-11-03", "2017-03-30")
```

CRUD:

Create:
- add a column for rownumber.
- discover insights of data.
- retrieve with age, slider of numeric
- employment
- Social attributes.
- count for subtotal - total, plot graph

D:
Mark for not included in the 

C:
Add new.

U:

# Rules of Thumb for design data storage
* Use list to store app data, i.e. configuration.
* User data frame to store user data.
* You need column **item_id** to put into every_table. It can be number or character. Make it unique. So you need to keep the current highest number in another place.
* Delete is not good for customer data. add a column name with a common name, e.g. SYS_DEL.

| position_id | call_put | amount | strike | SYS_DEL |
| X123        |          |        |        |

# Wide format <=> Long format

Wide format is more familiar to us. Column name is the data attribute. Long format is what we reformat the data that common attributes are gathered together as a single variable.

## Wide format
```{r echo = FALSE}
wfmt <- data_frame(date = seq(from = as.Date("2017-01-01"), by = "day", length.out = 5),
                   Copper_qty = round(runif(5) * 1000, 0),
                   Gold_qty = round(runif(5) * 1000, 0),
                   Silver_qty = round(runif(5) * 1000, 0))
wfmt
```

## Long format
```{r echo = FALSE}
gather(wfmt, key, value, -date)
```

# Wide format <=> Long format 1
```{r echo = TRUE }
mini_iris <- iris[1:3,]
```

```{r echo = TRUE }
gather(mini_iris, key = flower_att, value = measurement, -Species)
```

```{r echo = TRUE }
lfmt <- gather(mini_iris, key = flower_att, value = measurement, Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)
lfmt
```

gather(data, key, value, ...)
... is where you want to make as independent columns.
You need to specify all columns that should be gathers (or remove all columns that should _not_be gathered):

# Spread

    spread(lfmt, key, value)

Example
Get row sum.

```{r echo = TRUE }
wfmt %>%
  gather(key, value, -date) %>%
  group_by(date) %>%
  summarize(value1 = sum(value)) %>%
  rename(value = value1) %>%
  mutate(key = "Total") %>%
  spread(key = key, value = value) %>%
  inner_join(wfmt, ., by = "date")
```

# separate/unite

separate(data, col, into, sep = "[^[:alnum:]]+", remove = TRUE,
  convert = FALSE, extra = "warn", fill = "warn", ...)

#> # A tibble: 6 Ã— 3
#>       country  year              rate
#> *       <chr> <int>             <chr>
#> 1 Afghanistan  1999      745/19987071
#> 2 Afghanistan  2000     2666/20595360
#> 3      Brazil  1999   37737/172006362
#> 4      Brazil  2000   80488/174504898
#> 5       China  1999 212258/1272915272
#> 6       China  2000 213766/1280428583

separate(rate, into = c("cases", "population"))
separate(rate, into = c("cases", "population"), convert = TRUE)

unite(new, century, year) # default sep is "_"
unite(new, century, year, sep = "") # seamless unite

do(df, {
  some_message = a

})

- Pivot over multiple columns.

pivoting table

# Assignment
* Book option trades
* https://finance.google.com/finance/option_chain?q=NASDAQ%3AAMZN&ei=iIoAWvDmF8GqugSsj5mICw
* Date | Strike | Quantity | Underlying | Long/Short | Call/Put
* 
* Book bank transactions
* Book option trade transactions

* Market 

* Market data / quandl

```{r, echo = T}
library(fOptions)

a <- GBSCharacteristics(TypeFlag = "c", S = 1.5600, X = 1.6000,  Time = 1/2, r = 0.06, b = 0.06-0.08, sigma = 0.12)

GBSOption(TypeFlag = "p", S = 3500, X = 3765, Time = 1/12, r = 0, b = 0, sigma = 0.3)@price
GBSGreeks("delta", TypeFlag = "p", S = 3500, X = 3765,  Time = 1/12, r = 0, b = 0, sigma = 0.3)
GBSGreeks("delta", TypeFlag = "p", S = 3500, X = 3765,  Time = 1/365, r = 0, b = 0, sigma = 0.3)

y <- rep(0,0)
ii <- seq(from=1/12, to=1/365, by = -(1/365))
for (i in ii) {
  x <- GBSGreeks("delta", TypeFlag = "p", S = 3500, X = 3765,  Time = i, r = 0, b = 0, sigma = 0.3)
  x <- GBSOption(TypeFlag = "p", S = 3500, X = 3765, Time = i, r = 0, b = 0, sigma = 0.3)@price
  y <- c(y, x)
}
plot(ii, y)

GBSVolatility(price = 200, TypeFlag = "p", S = 3500, X = 3700, Time = 1/12, r = 0, b = 0)
GBSOption(TypeFlag = "p", S = 3500, X = 3500,  Time = 1/12, r = 0, b = 0, sigma = 0.74)@price
GBSOption(TypeFlag = "p", S = 3500, X = 3500,  Time = 1/12, r = 0, b = 0, sigma = 0.74)@price
Black76Option(TypeFlag = "p", FT = 3500, X = 3500,  Time = 1/12, r = 0, sigma = 0.74)@price

GBSGreeks("delta", TypeFlag = "p", S = 3500, X = 3500,  Time = 1/12, r = 0, b = 0, sigma = 0.74)
GBSGreeks("delta", TypeFlag = "p", S = 3500, X = 3500,  Time = 1/365, r = 0, b = 0, sigma = 0.3)

y <- rep(0,0)
ii <- seq(from=1/12, to=1/365, by = -(1/365))
vool <- seq(from=0.74, to=0.3, length.out=length(ii))
for (i in seq(1,length(ii))) {
  x <- GBSGreeks("delta", TypeFlag = "p", S = 3500, X = 3765,  Time = i, r = 0, b = 0, sigma = 0.3)
  x <- GBSOption(TypeFlag = "p", S = 3500, X = 3700,  Time = ii[i], r = 0, b = 0, sigma = vool[i])@price
  y <- c(y, x)
}
plot(ii, y)
```

Data analytics

nrow(ozone)
ncol(ozone)

str()

head(ozone[, c(6:7, 10)])
tail(bank[])

Hypothesis?
Does season matters?
Does employment matters?
Does age matters?

boxplot(bank$age, col = "blue")

> hist(bank$age, col = "orange")
> rug(bank$age)

> hist(bank$age, col = "green", breaks = 100)
> rug(bank$age)

> library(ggplot2)


> qplot(latitude, pm25, data = pollution, facets = . ~ region)

select(ozone, State.Name) %>% unique %>% nrow

> filter(ozone, State.Name == "Oklahoma" & County.Name == "Caddo") %>%
+         mutate(month = factor(months(Date.Local), levels = month.name)) %>%
+         group_by(month) %>%
+         summarize(ozone = mean(Sample.Measurement))


# color
> library(RColorBrewer)
> display.brewer.all()

# matrix/heatmap

> set.seed(12345)
> dataMatrix <- matrix(rnorm(400), nrow = 40)
> image(1:10, 1:40, t(dataMatrix)[, nrow(dataMatrix):1])

> heatmap(dataMatrix)




# Shiny

For uiOutput, output$h1 <- renderUI({ tagList(
                                            sliderInput("n", "N", 1, 1000, 500),
                                            textInput("label", "Label"))
                                        })

## Dynamic UI for Report

    renderUI({
      htmlOutput("t1"),
      plotOutput("p1")
    })

append into tagList()
Case: scenarios

For uiOutput, output$h1 <- renderUI({ tagList(
                                            sliderInput("n", "N", 1, 1000, 500),
                                            textInput("label", "Label"))
                                        })

Server - Client

User Interface (UI)
Server Instructions (Server)

updateSelectionInput(...)

# Question?
Age with respect to anything else.
With facets

# Display output with render*() functions

# ggplot/grid/gridExtra
# knitr/kableExtra

    `r chunk`{r shiny_block}
    library(knitr)
    library(kableExtra)
    
    # This is HTML output
    kable(df, format = "html")
    
    # Use function() { } to output html
    output$p1 <- function() {
      kable(df, format = "html")
    }
    `r chunk`

kable_styling(x_html, "striped", position = "left", font_size = 7)

7 render*() functions

renderDataTable() # an interactive table from data frame, matrix or other table-like structure
renderImage() # an image (saved as a link to the source image file)
renderPlot() # a plot generated on-the-fly
renderPrint() # code block
renderTable() # a static table from df, mat, etc.
renderText() # a character string
renderUI() # a shiny UI element
renderHTML() # html tags

# render*() arguments are code used to build and rebuild object
render*() function reruns the code with every change in the input

# reactive() object

data <- reactive( { hist(rnorm(input$num)) } )

output$hist <- renderPlot({ hist(data()) })
output$stat <- renderPlot({ summary(data()) })

allow multiple binding of data to different input

# isolate()

isolate({ rnorm(input$num) })
isolate(input$title)

# reactive 

actionButton(inputId = "go", label = "Click me")

observeEvent(input$go, { print(input$go) })

observeEvent(input$go, { print(as.numeric(input$go)) })

# observe() function
observe({ print(input$go) }) reacts to whatever are changed in the code block.

# eventReactive() delay reactions
data <- eventReactive(input$go, { rnorm(input$num) })

button -> data -> renderPlot

button -> renderPlot (direct is not very good)

mono-action to data binding

# reactiveValues
rv <- reactiveValues(data = rnorm(100))

button -> change the data -> renderPlot

allow multiple binding of data to different input

# When it gets to run.
ui: client. run once per user per session.
server: run once per session
code inside a reactive function runs with every input change.
