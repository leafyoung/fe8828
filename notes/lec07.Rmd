```{r setup, include=FALSE}
library(tidyverse)
knitr::opts_chunk$set(echo = FALSE, fig.align="center")
bank <- read.csv("../example/data-bank/bank.csv", sep=";")
```

Data analytics

nrow(ozone)
ncol(ozone)

str()

head(ozone[, c(6:7, 10)])
tail(bank[])

Hypothesis?
Does season matters?
Does employment matters?
Does age matters?

boxplot(bank$age, col = "blue")

> hist(bank$age, col = "orange")
> rug(bank$age)

> hist(bank$age, col = "green", breaks = 100)
> rug(bank$age)

> library(ggplot2)
> qplot(latitude, pm25, data = pollution, facets = . ~ region)

select(ozone, State.Name) %>% unique %>% nrow

> filter(ozone, State.Name == "Oklahoma" & County.Name == "Caddo") %>%
+         mutate(month = factor(months(Date.Local), levels = month.name)) %>%
+         group_by(month) %>%
+         summarize(ozone = mean(Sample.Measurement))


# color
> library(RColorBrewer)
> display.brewer.all()

# matrix/heatmap

> set.seed(12345)
> dataMatrix <- matrix(rnorm(400), nrow = 40)
> image(1:10, 1:40, t(dataMatrix)[, nrow(dataMatrix):1])

> heatmap(dataMatrix)

# Wide format <=> Long format

Wide format is more familiar to us. Column name is the data attribute. Long format is what we reformat the data that common attributes are gathered together as a single variable.

## Wide format
```{r echo = FALSE}
wfmt <- data_frame(date = seq(from = as.Date("2017-01-01"), by = "day", length.out = 5),
                   Copper_qty = round(runif(5) * 1000, 0),
                   Gold_qty = round(runif(5) * 1000, 0),
                   Silver_qty = round(runif(5) * 1000, 0))
wfmt
```

## Long format
```{r echo = FALSE}
gather(wfmt, key, value, -date)
```

# Wide format <=> Long format 1
```{r echo = TRUE }
mini_iris <- iris[1:3,]
```

```{r echo = TRUE }
gather(mini_iris, key = flower_att, value = measurement, -Species)
```

```{r echo = TRUE }
lfmt <- gather(mini_iris, key = flower_att, value = measurement, Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)
lfmt
```

gather(data, key, value, ...)
... is where you want to make as independent columns.
You need to specify all columns that should be gathers (or remove all columns that should _not_be gathered):


# Spread
```{r echo = TRUE }
spread(lfmt, key, value)
```

Example
Get row sum.

wfmt %>%
  gather(key, value, -date) %>%
  group_by(date) %>%
  summarize(value1 = sum(value)) %>%
  rename(value = value1) %>%
  mutate(key = "Total") %>%
  spread(key = key, value = value) %>%
  inner_join(wfmt, ., by = "date")

# separate/unite

separate(data, col, into, sep = "[^[:alnum:]]+", remove = TRUE,
  convert = FALSE, extra = "warn", fill = "warn", ...)

#> # A tibble: 6 Ã— 3
#>       country  year              rate
#> *       <chr> <int>             <chr>
#> 1 Afghanistan  1999      745/19987071
#> 2 Afghanistan  2000     2666/20595360
#> 3      Brazil  1999   37737/172006362
#> 4      Brazil  2000   80488/174504898
#> 5       China  1999 212258/1272915272
#> 6       China  2000 213766/1280428583

separate(rate, into = c("cases", "population"))
separate(rate, into = c("cases", "population"), convert = TRUE)

unite(new, century, year) # default sep is "_"
unite(new, century, year, sep = "") # seamless unite


do(df, {
  some_message = a

})

- Pivot over multiple columns.

pivoting table

## ggplot

ggplot(data = <DATA>) + 
  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))

Put the + sign in the end of the line, not the beginning of the line.

WRONG
~~ggplot(data = <DATA>)~~
~~+ <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))~~


## Use the categorical variable to differtiate between different groups.

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class))

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, size = class))

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))

ggplot(data = mpg) + 
  geom_line(mapping = aes(x = displ, y = hwy, group = class))


## you can also enforce
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")

# ggplot system

library(ggplot2)
ggplot(airquality, aes(Temp, Ozone)) + 
        geom_point() + 
        geom_smooth(method = "loess", se = FALSE)


Which variables in mpg are categorical? Which variables are continuous?

# simply plot x and y
qplot(age, balance, data = bank)
qplot(age, balance, data = bank, color = job)

# for non-numeric data
qplot(default, age, data = bank)
qplot(age, default, data = bank)
qplot(job, age, data = bank)

# add a geometry
qplot(age, balance, data = bank, geom = c("point", "smooth"))
qplot(age, balance, data = bank, color = job, geom = c("point", "smooth"))

# histogram
ggplot(data = bank, mapping = aes(x = duration, fill = job)) + geom_histogram(binwidth = 2)
ggplot(data = bank, mapping = aes(x = duration, fill = job)) + geom_histogram(binwidth = 100)

ggplot(data = bank, mapping = aes(x = age, fill = job)) + geom_histogram(binwidth = 10)
ggplot(data = bank, mapping = aes(x = age, colour = job)) + geom_freqpoly(binwidth = 10)

# geom_bar: lowest granuity or
ggplot(data = bank, mapping = aes(x = age, colour = job)) + geom_bar()

# geom_bar: better serves for categorical data
ggplot(data = bank, mapping = aes(x = job, fill = education)) + geom_bar()
ggplot(data = bank, mapping = aes(x = job, fill = education)) + geom_bar() + coord_flip()
ggplot(data = bank, mapping = aes(x = reorder(job, age, FUN = mean), fill = education)) +
  geom_bar() +
  coord_flip()

ggplot(data = bank, mapping = aes(x = reorder(job, age, FUN = mean), fill = education)) +
  geom_bar() +
  scale_x_discrete(limit = rev(levels(reorder(bank$job, bank$age, FUN = mean)))) +
  coord_flip()

# model

library(modelr)

mod <- lm(log(balance) ~ log(age), data = bank)

bank1 <- filter(bank, default == "no" & balance > 0)
mod <- lm(log(balance) ~ log(age), data = bank1)

bank2 <- bank1 %>% 
  add_residuals(mod) %>% 
  mutate(resid = exp(resid))

ggplot(data = bank2) + 
  geom_point(mapping = aes(x = age, y = resid))

# density
qplot(balance, data = bank, fill = job, geom = "density")
qplot(duration, data = bank, fill = job, geom = "density")
qplot(age, data = bank, color = job, geom = "density")
v.s.
qplot(age, data = bank, fill = job, geom = "density")
qplot(age, data = bank, color = job, fill = job, geom = "density")

# boxplot
qplot(job, duration, data = bank, geom = "boxplot")
qplot(job, balance, data = bank, geom = "boxplot")
qplot(job, age, data = bank, geom = "boxplot")

# Facets
qplot(pdays, data = bank, facets = job ~ ., binwidth = 2) # doesn't look great because we have so many jobs.
qplot(pdays, data = bank, facets = . ~ job, binwidth = 2) # not a good measure.
qplot(campaign, data = bank, facets = . ~ job, binwidth = 2)
qplot(duration, data = bank, facets = . ~ job, binwidth = 2)
qplot(balance, age, data = bank, facets = . ~ job)
qplot(age, balance, data = bank, facets = . ~ job)
qplot(age, balance, data = bank, facets = . ~ job) + geom_smooth()

Which is equivalent to
qplot(age, balance, data = bank, facets = . ~ job, geom = c("point", "smooth"))
qplot(age, balance, data = bank, facets = . ~ job, geom = "smooth")

# fill/color/shape can be each on one dimension of the data.
qplot(age, balance, data = bank, shape = marital, color = marital) + geom_smooth()
qplot(age, balance, data = bank, shape = job, color = marital) + geom_smooth()

# Insights Question
```{r}
qplot(age, job, data = bank, color = loan, shape = loan)
```

Things to consider:

- bio:
    + age
    + job
    + marital
    + education
- financial
    + default
    + balance
    + housing
    + loan
- communication
    + contact: celluar v.s. telephone v.s. unknown
    + day/month: maybe good to ignore?
    + duration:
    + campaign:
    + pdays:
    + previous:
    + poutcome:

# Which data is good to use?
qplot(previous, data = bank, facets = . ~ job, binwidth = 2)
v.s.
qplot(previous, data = bank, facets = . ~ marrital, binwidth = 2)

# ggplot2
Level 2

g <- ggplot(bank, aes(x = age, y = duration))

# Each + is a layer
g + geom_smooth()
g + geom_point() + geom_smooth()

To combine we have, g is for re-use
ggplot(bank, aes(x = age, y = duration)) + 
  geom_point() + geom_smooth()

g + geom_point() + geom_smooth(method = "lm") + facet_grid(. ~ job)
g + geom_point(color = "steelblue", size = 4, alpha = 1/2)
g + geom_point(aes(color = job), size = 4, alpha = 1/2)
g + geom_point() + geom_point(aes(color = job), size = 4, alpha = 1/2) # each + is a layer

# add theme
default theme is theme_gray()
g + geom_point(aes(color = job), size = 4, alpha = 1/2) + theme_bw()
g + geom_point(aes(color = job), size = 4, alpha = 1/2) + theme_times()

g <- ggplot(bank, aes(x = age, y = log(duration)))
g + geom_point(aes(color = job), size = 4, alpha = 1/2) + theme_bw()
g + geom_point(aes(color = job), size = 4, alpha = 1/2) + theme_bw() +
    labs(title = "Duration is longer with age",
         subtitle = "some random plot",
         caption = "from MFE") +
    labs(x = "age", y = expression("log " * Duration))

Levels gives more control to the layer and style.

cutpoints <- quantile(bank$age, seq(0, 1, length = 4), na.rm = TRUE)
# The age_group variable is now a categorical factor variable containing 3 levels, indicating the ranges of age.
bank$age_group <- cut(bank$age, cutpoints)
levels(bank$age_group)
g <- ggplot(bank, aes(age, duration)) +
     geom_point(alpha = 1/3) + 
     facet_wrap(job ~ age_group, ncol = 3) + # ncol = number of cuts 3 = length(levels(bank$age_group))
     geom_smooth(method="lm", se=FALSE, col="steelblue") + 
     theme_bw(base_family = "Avenir", base_size = 10) + 
     labs(x = "age", y = expression("log " * Duration)) + 
     labs(title = "Bank Clients")  
g

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2)

# ggplot with statistical transformation
ggplot(bank) + geom_bar(mapping = aes(x = age))
ggplot(bank) + geom_bar(aes(x = age)) # first input parameter to geom_bar is mapping, so we can skip it.
ggplot(bank) + geom_bar(mapping = aes(x = age, fill = job))

ggplot(bank) + geom_bar(mapping = aes(x = job))
ggplot(bank) +
  geom_bar(mapping = aes(x = job, fill = age)) # why this doesn't work. Age is a continous variable.

# Data with statistical
ggplot(data = bank) + 
  stat_summary(
    mapping = aes(x = age, y = balance),
    fun.ymin = min,
    fun.ymax = max,
    fun.y = median
  )

# Position for bar
ggplot(bank) + geom_bar(mapping = aes(x = age, fill = job), position = "dodge")
ggplot(bank) + geom_bar(mapping = aes(x = age, fill = job), position = "fill")

# Variations
ggplot(bank) + geom_bar(mapping = aes(x = age, fill = job), position = "fill") + coord_flip()
ggplot(bank) + geom_bar(mapping = aes(x = age, fill = job), position = "fill") + coord_polar()

# ggplot summary
ggplot(data = <DATA>) + 
  <GEOM_FUNCTION>(
     mapping = aes(<MAPPINGS>),
     stat = <STAT>, 
     position = <POSITION>
  ) +
  <COORDINATE_FUNCTION> +
  <FACET_FUNCTION>

# ggplot: one more thing.
```{r echo = FALSE}
install.packages("maps")
nz <- map_data("nz")
ggplot(nz, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", colour = "black") +
  coord_quickmap()

world <- map_data("world")
ggplot(world, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", colour = "black") +
  coord_quickmap()
```



# Add themes
package ggthemes provides many classical themes.

## [1] "theme_base" "theme_calc"
## [3] "theme_economist" "theme_economist_white"
## [5] "theme_excel" "theme_few"
## [7] "theme_fivethirtyeight" "theme_foundation"
## [9] "theme_gdocs" "theme_hc"
## [11] "theme_igray" "theme_map"
## [13] "theme_pander" "theme_par"
## [15] "theme_solarized" "theme_solarized_2"
## [17] "theme_solid" "theme_stata"
## [19] "theme_tufte" "theme_wsj"


## See the levels of the newly created factor variable
levels(maacs$no2tert)

# Shiny
Server - Client

User Interface (UI)
Server Instructions (Server)

updateSelectionInput(...)

# Question?
Age with respect to anything else.
With facets

# Dynamic UI
append into tagList()

insertUI
renderUI
scenarios

# App template:
    
    library(shiny)
    ui <- fluidPage("Hello World")
    server <- function(input, output) {}
    shinyApp(ui = ui, server = server)

# Think around Input and Outputs

  ui <- fluidPage(
    # Input() functions,
    # Output() functions
  )

# Input

  slideInput
  textInput
  passwordInput


  inputXXX(inputId = "input name", label = "label to display", ...)

# Output

  dataTableOutput()
  htmlOutput()
  imageOutput()

  plotOutput(outputId = "hist")

# Server

  server <- function(input, output) {
    output$hist <- # code
    output$hist <- renderDataTable()
    output$hist <- renderImage()
    output$hist <- renderPlot({ hist(rnorm(100)) })

    output$hist <- renderPlot({
      title("a normal random number histogram")
      hist(rnorm(input$num))
    })

  }

# reactivity will kick in

  input$num ------> renderPlot({ hist(rnorm(input$num)) })

# runing the app

Shiny server AMI

# reactivity
Reactivity links input to the output like a data flow

input$x => output$y

input$x => expression() => output$y

reactive values work together with reactive functions.

put input$XXX inside renderXXX

1. reactive value notifies.
2. reactive function responds.

# Display output with render*() functions

7 render*() functions

renderDataTable() # an interactive table from data frame, matrix or other table-like structure
renderImage() # an image (saved as a link to the source image file)
renderPlot() # a plot generated on-the-fly
renderPrint() # code block
renderTable() # a static table from df, mat, etc.
renderText() # a character string
renderUI() # a shiny UI element
renderHTML() # html tags

# render*() arguments are code used to build and rebuild object
render*() function reruns the code with every change in the input

# reactive() object

data <- reactive( { hist(rnorm(input$num)) } )

output$hist <- renderPlot({ hist(data()) })
output$stat <- renderPlot({ summary(data()) })

allow multiple binding of data to different input

# isolate()

isolate({ rnorm(input$num) })
isolate(input$title)

# reactive 

actionButton(inputId = "go", label = "Click me")

observeEvent(input$go, { print(input$go) })

observeEvent(input$go, { print(as.numeric(input$go)) })

# observe() function
observe({ print(input$go) }) reacts to whatever are changed in the code block.

# eventReactive() delay reactions
data <- eventReactive(input$go, { rnorm(input$num) })

button -> data -> renderPlot

button -> renderPlot (direct is not very good)

mono-action to data binding

# reactiveValues
rv <- reactiveValues(data = rnorm(100))

button -> change the data -> renderPlot

allow multiple binding of data to different input

# When it gets to run.
ui: client. run once per user per session.
server: run once per session
code inside a reactive function runs with every input change.
