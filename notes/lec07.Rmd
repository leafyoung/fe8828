---
title: "FE8828 Programming Web Applications in Finance"
subtitle: "<sub> Week 3 <br> Data, visualization, and web: part 2 </sub>"
author: "Dr. Yang Ye <sub> <Email:yy@runchee.com> </sub>"
date: "Nov 16, 2017"
# runtime: shiny
---

<style type="text/css">

code.r{ /* Code block */
    font-size: 18px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 15px;
}
</style>

```{r setup, include=FALSE}
library(tidyverse)
library(shiny)
library(lubridate)
library(bizdays)
library(fOptions)
library(ggplot2)
knitr::opts_chunk$set(echo = FALSE, fig.align="center", collapse = TRUE, cache = T)
chunk <- "```"
inline <- function(x = "") paste0("`` `r ", x, "` ``")
bank <- read.csv("https://goo.gl/PBQnBt", sep = ";")
```

# Lecture 7: Data Part 2

# Joins

```{r, echo = FALSE, out.width = "75%"}
knitr::include_graphics("imgs/join_today_header_image.jpg")
```

# `left_join / right_join / anti_join / full_join`

| Position_id | Buy/Sell | Quantity | Risk Factor |

Positions are additive (to close a position, we won't change the original position but to do a new reverse trade).
Suppose we have two days of position data.

    new_data <- filter(position, date == new_date)
    old_data <- filter(position, date == old_date)

In order to find the new positions. We will use:

    # order matters, new_data needs to be placed first.
    anti_join(new_data, old_data, by = "position_id")

In order to find old positions, we will use:

    # inner_join ignores order
    inner_join(new_data, old_data, by = "position_id")
    left_join(old_data, new_data, by = "position_id") # produce the same result
    right_join(new_data, old_data, by = "position_id") # produce the same result

# `left_join / right_join`
Can be used to do mapping table (aka. vlookup)

Table a:

    | type_code | type_name |
    | 1         | orange    |
    | 2         | banana    |

Table b:

    | type_code | quantity | customer_id |
    | 1         | 1        | A           |
    | 2         | 3        | B           |
    | 3         | 4        | C           |
    | 2         | 2        | D           |
    | 1         | 6        | B           |

Table c:

    | customer_id | customer_phone |
    | A           | +123           |
    | B           | +456           |
    | C           | +789           |

left_join(b, a, by = "type_code") %>% left_join(c, by = "customer_id")

    | type_code | quantity | customer_id | type_name | customer_phone |
    | 1         | 1        | A           | orange    | +123           |
    | 2         | 3        | B           | banana    | +456           |
    | 3         | 4        | C           | NA        | +789           |
    | 2         | 2        | D           | banana    | NA             |
    | 1         | 6        | B           | orange    | +456           |

Join can be multiple types

## `full_join`
Find all combinations between table a and b.

```{r, echo = T}
# all possible combination 
x <- full_join(distinct(bank, job) %>% mutate(x = 1), distinct(bank, education) %>% mutate(x = 1)) %>% select(-x)
y <- distinct(bank, job, education)

anti_join(x, y)
anti_join(y, x)

nrow(x)
nrow(y)
```

# Join is a set operation

- `full_join` is `*`
- `anti_join` is `-`
- `inner_joins` is `-`, `/`
- `left_join/right_join` is either just the same, or `*`, `/`. 

# `group_by` / `summarize`
Group_by is our way leading to analyze the data.

    group_by(df, ...) ... is the list of variables
    summarize(df, new_field = some_func_can_process_bulk_data())

Function can process bulk data:
Note: I often forgot there are existing functions that resort to longer versions.

- sum/mean/median/sd
- min(x), quantile(x, 0.25), max(x):
- n() / n_distinct():
- ntile: a rough divide into a few groups
- first(x), nth(x, 2), last(x)

# `group_by` / `summarize`: Examples

```{r, echo = T}
# add paramter na.rm, if there is na
df <- data.frame(a = c(1, 3, 4, NA))
summarise(df, total = sum(a))
summarise(df, total = sum(a, na.rm = T))
summarise(df, total = mean(a))
summarise(df, total = mean(a, na.rm = T))
```

# `group_by` / `summarize`: Examples 2

```{r, echo = T}
# count number of people in each age group
group_by(bank, age) %>% summarise(n = n())
group_by(bank, age) %>% summarise(n = n()) %>% plot

bank1 <- group_by(bank, age) %>%
  summarise(balance_mean = mean(balance),
            count = n(),
            default_count = sum(ifelse(default == "no", 0, 1)))

head(bank1)

# If combined with ggplot, to be learnt in next session
ggplot(bank1, aes(x = age, y = balance_mean)) +
  geom_point(aes(size = count), alpha = 1/4, color = "red") +
  geom_point(aes(size = default_count), alpha = 1/3, color = "blue") +
  geom_smooth(se = F)
```

# Group filter
```{r, echo = T}
# Find the maximum and minimum balance on each age.
bank %>% 
  group_by(age) %>%
  filter(min_rank(balance) == 1 | min_rank(desc(balance)) == 1) %>%
  arrange(age, balance)
```

```{r, echo = T}
# Find the big age group
bank %>% 
  group_by(age %/% 10) %>%
  filter(n()/nrow(bank) > 0.2) %>%
  arrange(age)
```
# Count for condition
TRUE => 1, FALSE => 0

```{r, echo = T}
# Generate a report for balance and job
d1 <- group_by(bank, job) %>% summarise(`balance > 500` = sum(balance > 500))
d2 <- group_by(bank, job) %>% summarise(`balance <= 500` = sum(balance <= 500))
d <- distinct(bank, job) %>% arrange(job)
d <- left_join(d, d1, by = "job")
d <- left_join(d, d2, by = "job")
d <- mutate(d, total = `balance > 500` + `balance <= 500`)
d
```

# Group_by and Summarise: a metaphor
group_by is a like folding a paper without tearing it later.
summarise will tear the paper.
Therefore, group_by can be used with other verbs, `mutate`, `filter`, which will work within the group.
summarise can be used without group_by, then it will apply to entire data as one whole group.

```{r, echo = T}
# mutate with group_by
group_by(data.frame(a = 1:10), quartile = ntile(a, 2)) %>% mutate(b = a / sum(a))
```

```{r, echo = T}
# filter with group_by
group_by(bank, age) %>% dplyr::filter(balance == max(balance))
```

```{r, echo = T}
# summarise with group_by
group_by(data.frame(a = 1:10), quartile = ntile(a, 2)) %>% summarise(b = sum(a))
```

```{r, echo = T}
# summarise without a group_by
summarise(bank, with_housing = sum(housing == "yes") / n(),
          age_min = min(age),
          duration_mean = mean(duration))
```

# group_by/rowwise/ungroup
ungroup() removes group definition, restores the `ungrouped` data frame back to entire data.
Because group_by operation will leave a trace 

```{r, echo = T}
# wrong
group_by(bank, age) %>% dplyr::filter(balance == max(balance)) %>% summarize(balance = mean(balance)) %>% head(n = 3)
# correct
group_by(bank, age) %>% dplyr::filter(balance == max(balance)) %>% ungroup %>% summarize(balance = mean(balance))

# can't remove age
group_by(bank, age) %>% dplyr::filter(balance == max(balance)) %>% select(-age) %>% head(n = 3)
# R: Adding missing grouping variables: `age`
# can remove age
group_by(bank, age) %>% dplyr::filter(balance == max(balance)) %>% ungroup %>% select(-age) %>% head(n = 3)
```

# rowwise
Sometimes, we need to use `rowwise()` which is a special `group_by` which just makes every one row a group.
Use case, it applies to complex logic that can't be applied as a group.

```{r, echo = T}
df <- data.frame(throw_dices = 1:10)
rowwise(df) %>% mutate( mean = mean(sample(1:6, throw_dices, replace = T)))
```

# Exercise with group_by/summarise
- How to know the row number of the wrong date
```{r, echo = T}
df <- data.frame(x = c("2017-10-01", "2017-31-12", "2017-03-17", "2017-02-29", "2017-09-30"))
df
```
```{r, echo = F}
df %>%
    ungroup() %>%
    mutate(nnn = 1:n()) %>%
    mutate(x = as.Date(x)) %>%
    dplyr::filter( is.na(x)) %>%
    { cat(paste0("Wrong dates on: " .$nnn, collapse = ", ")) }
```

- How to get sub-total and total on mean of age and balance, group by job and education?

| job       | education | mean(Age) | median(Balance) |
| services  | primary   | ...       | ...             |
| services  |           | 
| services  | +         | ...       | ...             |
| ...
| +         | +         | ...       | ...             |

- To evaluate a portfolio of options for its total value.

```{r, echo = T}
GBSOption(TypeFlag = "p", S = 3500, X = 3765, Time = 1/12, r = 0, b = 0, sigma = 0.3)@price
df <- data.frame(type = sample(c("c", "p"), 100, replace = T),
                 strike = round(runif(100) * 100, 0),
                 underlying = round(runif(100) * 100, 0),
                 Time = 1,
                 r = 0.01,
                 b = 0,
                 sigma = 0.3)
```

# `bind_rows`
- bind_rows is the `+` operator for data frames.

```{r, echo = T}
# add empty data frame is the same.
bind_rows(data.frame(a = 3:4), data.frame())
bind_rows(data.frame(), data.frame(a = 3:4))
```

# `bind_rows`: Use case

I usually use bind_rows to collect results. For example,

    new_positions <- data.frame()
    closed_positions <- data.frame()

    for (i in length(dates)-1) {
      old_date <- dates[i]
      new_date <- dates[i+1]

      new_data <- filter(position, date == new_date)
      old_data <- filter(position, date == old_date)

      new_positions <- bind_rows(new_positions,
                                 anti_join(new_data, old_data, by = "position_id"))
    }

    # new_positions contains all new positions on day 1

# `bind_rows`: Use case

If row order matters, bind_row can be used to re-order/splice and recombine.

```{r, echo = T}
# Get head and tail
# Note: use { } to use the .
arrange(bank, age) %>%
{ bind_rows(head(., n = 5), tail(., n = 5)) }

# summary
summarise_if(bank, is.numeric, mean)
# add summary to the records
tail(bind_rows(bank, summarise_if(bank, is.numeric, mean)), n = 1)
# bind_rows can match column names and type.
# let's adjust the column order.
# As due-deligence, better to check the result.
# I remember earlier version of dplyr doesn't do match.
tail(bind_rows(bank, summarise_if(bank, is.numeric, mean) %>% select(balance, day, everything())), n = 1) 
```
   
# bind_cols
- bind_cols is to extend the data frame in width.

Use cases
- It's a lazyman's `left_join` or `select`
- It copies the columns
- I usually find it useful to generate data frame for reports.

```{r, echo = T}
dt1 <- bind_cols(select(bank, job), select(bank, education))
dt1[1:3,]
dt2 <- bind_cols(dt1, dt1)
dt2[1:3,]

d1 <- dplyr::filter(bank, month == "sep") %>% summarize(duration = mean(duration)) %>% rename(`Duration Sep` = duration)
d2 <- dplyr::filter(bank, month == "oct") %>% summarize(duration = mean(duration)) %>% rename(`Duration Oct` = duration)
d3 <- dplyr::filter(bank, month == "nov") %>% summarize(duration = mean(duration)) %>% rename(`Duration Nov` = duration)

bind_cols(dplyr::filter(bank, month == "sep") %>% summarize(duration = mean(duration)) %>% rename(`Duration Sep` = duration),
          dplyr::filter(bank, month == "oct") %>% summarize(duration = mean(duration)) %>% rename(`Duration Oct` = duration),
          dplyr::filter(bank, month == "nov") %>% summarize(duration = mean(duration)) %>% rename(`Duration Nov` = duration))
```

# tidyr: gather/spread

Wide format <=> Long format

- Wide format is more familiar to us. Column name is the data attribute.
- Long format is what we reformat the data that common attributes are gathered together as a single variable.
- Reference: Tidy data <https://en.wikipedia.org/wiki/Tidy_data>

## Wide format
```{r echo = FALSE}
wfmt <- data_frame(date = seq(from = as.Date("2017-01-01"), by = "day", length.out = 5),
                   Copper_qty = round(runif(5) * 1000, 0),
                   Gold_qty = round(runif(5) * 1000, 0),
                   Silver_qty = round(runif(5) * 1000, 0))
wfmt
```

## Long format
```{r echo = FALSE}
library(tidyr)
gather(wfmt, key, value, -date)
```

# `spread/gather` conversion for Wide format <=> Long format
    gather(data, key, value, ...)
    
... is where you want to make as independent columns.
You need to specify all columns that should be gathers (or remove all columns that should _not_be gathered):


```{r echo = TRUE }
mini_iris <- iris[1:3,]
gather(mini_iris, key = flower_att, value = measurement, -Species)
```

```{r echo = TRUE }
lfmt <- gather(mini_iris, key = flower_att, value = measurement, Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)
lfmt
```
# Spread

    spread(lfmt, key, value)

Example
Get row sum.

```{r echo = TRUE }
library(tidyr)
wfmt %>%
  gather(key, value, -date) %>%
  group_by(date) %>%
  summarize(value1 = sum(value)) %>%
  rename(value = value1) %>%
  mutate(key = "Total") %>%
  spread(key = key, value = value) %>%
  inner_join(wfmt, ., by = "date")
```

```{r, echo = T}
# although this works...
# No hard coding of column names "Copper_qty Gold_qty Silver_qty".
wfmt %>% mutate(total = Copper_qty + Gold_qty + Silver_qty)
```

# `separate/unite`

separate(data, col, into, sep = "[^[:alnum:]]+", remove = TRUE,
  convert = FALSE, extra = "warn", fill = "warn", ...)

#> # A tibble: 6 × 3
#>       country  year              rate
#> *       <chr> <int>             <chr>
#> 1 Afghanistan  1999      745/19987071
#> 2 Afghanistan  2000     2666/20595360
#> 3      Brazil  1999   37737/172006362
#> 4      Brazil  2000   80488/174504898
#> 5       China  1999 212258/1272915272
#> 6       China  2000 213766/1280428583

separate(rate, into = c("cases", "population"))
separate(rate, into = c("cases", "population"), convert = TRUE)

unite(new, century, year) # default sep is "_"
unite(new, century, year, sep = "") # seamless unite


# CRUD:

Create:
- add a column for rownumber.
- discover insights of data.
- retrieve with age, slider of numeric
- employment
- Social attributes.
- count for subtotal - total, plot graph

D:
Mark for not included in the 

C:
Add new.

U:

# Rules of Thumb for design data storage
* Use list to store app data, i.e. configuration.
* User data frame to store user data.
* You need column **item_id** to put into every_table. It can be number or character. Make it unique. So you need to keep the current highest number in another place.
* Delete is not good for customer data. add a column name with a common name, e.g. SYS_DEL.

| position_id | call_put | amount | strike | SYS_DEL |
| X123        |          |        |        |

# Assignment
1. Exploratory Data
Work on the bank dataset. Find 10 findings from data.
Use R Markdown.

    ---
    title: "FE8828 Assignment for Exploratory Data Analysis"
    author: "Yang Ye <sub> <Email:yy@runchee.com> </sub>"
    date: "Nov 15, 2017"
    output: html_document
    ---

    ```{r setup, include=FALSE}
    library(tidyverse)
    library(lubridate)
    library(bizdays)
    knitr::opts_chunk$set(echo = FALSE, fig.align="center", collapse = TRUE, cache = T)
    bank <- read.csv("https://goo.gl/PBQnBt", sep = ";")
    ```

    # Finding #1
    This data contains `r nrow(data)` rows.

    # Finding #2

2. Book option trades
1.1 Store the options from 
* https://finance.google.com/finance/option_chain?q=NASDAQ%3AAMZN&ei=iIoAWvDmF8GqugSsj5mICw
| Date | Strike | Quantity | Underlying | Long/Short | Call/Put
1.2 Count the total valuation of call alone, put alone, call and put.
1.3 Find those in the money.
1.4. Plot the volatility curve, strike v.s. vol

```{r, echo = T}
# GBSVolatility(price, TypeFlag, S, X, Time, r, b, tol, maxiter)
# Use Price to back-out implied volatility
GBSVolatility(867.30, "c", 1135.67, 240, as.numeric((as.Date("2018-01-19") - as.Date("2017-11-15")))/365, r = 0.01, b = 0)
GBSVolatility(256.50, "c", 1135.67, 880.00, as.numeric((as.Date("2018-01-19") - as.Date("2017-11-15")))/365, r = 0.01, b = 0)
GBSVolatility(53.62, "c", 1135.67, 1120.00, as.numeric((as.Date("2018-01-19") - as.Date("2017-11-15")))/365, r = 0.01, b = 0)
```

3. Bank (Group - choose a coordinator to send me the report)
Data frame 1: Account 
| Acount No | Name |

Data frame 2: Transaction
| Date | Account | Action | Amount | Currency |

Data frame 3: Currency to SGD
| Currency | Conversion | Date |

Action can only be: Withdraw/Deposit/Spend
Write follow functions and use them to initialize the data.

1. Create 10 accounts with initial random deposit and credit in SGD.
2. Create 3 currencies: CNY, USD, SGD. Download their conversion rate between 2017-07-01 and 2017-09-30.
3. Generate random transaction data for 10 accounts during 2017-07-01 and 2017-09-30.
   Make it more realistic, deposite is 1-2 times per month, a random number of 3000-5000.
   Spend/Withdraw can be any times and any amount.
   Deposit is positive, Withdraw/Spend is negative.
   You can't withdraw more than the deposit, can't spend more than credit + deposit.
4. Generate report for transaction as month-end statement in SGD.

    {Name}

    Date | Action | Amount | Currency | Deposite Balance | Credit Balance |



    -----------------------------------------------------------------------
                   Month-End Balance |

    Summary:

    Item | Deposit | Amount |


Submission:
1. A report describing interesting learning points on design and coding (1-2 pages, just be concise)
2. Code with decent amount of comments
3. Example running result.

Data analytics

# install.packages("plyr")

ozone <- plyr::ozone

nrow(ozone)
ncol(ozone)

str()

head(ozone[, c(6:7, 10)])
tail(bank[])

Hypothesis?
Does season matters?
Does employment matters?
Does age matters?

boxplot(bank$age, col = "blue")

> hist(bank$age, col = "orange")
> rug(bank$age)

> hist(bank$age, col = "green", breaks = 100)
> rug(bank$age)

> library(ggplot2)

> qplot(latitude, pm25, data = pollution, facets = . ~ region)

select(ozone, State.Name) %>% unique %>% nrow

> filter(ozone, State.Name == "Oklahoma" & County.Name == "Caddo") %>%
+         mutate(month = factor(months(Date.Local), levels = month.name)) %>%
+         group_by(month) %>%
+         summarize(ozone = mean(Sample.Measurement))


# color
> library(RColorBrewer)
> display.brewer.all()

# matrix/heatmap

> set.seed(12345)
> dataMatrix <- matrix(rnorm(400), nrow = 40)
> image(1:10, 1:40, t(dataMatrix)[, nrow(dataMatrix):1])

> heatmap(dataMatrix)


# Shiny

For uiOutput, output$h1 <- renderUI({ tagList(
                                            sliderInput("n", "N", 1, 1000, 500),
                                            textInput("label", "Label"))
                                        })

## Dynamic UI for Report

    renderUI({
      htmlOutput("t1"),
      plotOutput("p1")
    })

append into tagList()
Case: scenarios

For uiOutput, output$h1 <- renderUI({ tagList(
                                            sliderInput("n", "N", 1, 1000, 500),
                                            textInput("label", "Label"))
                                        })

Server - Client

User Interface (UI)
Server Instructions (Server)

updateSelectionInput(...)

# Question?
Age with respect to anything else.
With facets

# Display output with render*() functions

# ggplot/grid/gridExtra
# knitr/kableExtra

    `r chunk`{r shiny_block}
    library(knitr)
    library(kableExtra)
    
    # This is HTML output
    kable(df, format = "html")
    
    # Use function() { } to output html
    output$p1 <- function() {
      kable(df, format = "html")
    }
    `r chunk`

kable_styling(x_html, "striped", position = "left", font_size = 7)

7 render*() functions

renderDataTable() # an interactive table from data frame, matrix or other table-like structure
renderImage() # an image (saved as a link to the source image file)
renderPlot() # a plot generated on-the-fly
renderPrint() # code block
renderTable() # a static table from df, mat, etc.
renderText() # a character string
renderUI() # a shiny UI element
renderHTML() # html tags

# render*() arguments are code used to build and rebuild object
render*() function reruns the code with every change in the input

# reactive() object

data <- reactive( { hist(rnorm(input$num)) } )

output$hist <- renderPlot({ hist(data()) })
output$stat <- renderPlot({ summary(data()) })

allow multiple binding of data to different input

# isolate()

isolate({ rnorm(input$num) })
isolate(input$title)

# reactive 

actionButton(inputId = "go", label = "Click me")

observeEvent(input$go, { print(input$go) })

observeEvent(input$go, { print(as.numeric(input$go)) })

# observe() function
observe({ print(input$go) }) reacts to whatever are changed in the code block.

# eventReactive() delay reactions
data <- eventReactive(input$go, { rnorm(input$num) })

button -> data -> renderPlot

button -> renderPlot (direct is not very good)

mono-action to data binding

# reactiveValues
rv <- reactiveValues(data = rnorm(100))

button -> change the data -> renderPlot

allow multiple binding of data to different input

# When it gets to run.
ui: client. run once per user per session.
server: run once per session
code inside a reactive function runs with every input change.
