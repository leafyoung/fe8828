---
title: "FE8828 Programming Web Applications in Finance"
subtitle: "<sub> Week 2 <br> Data, visualization, and web: part 1 </sub>"
author: "Dr. Yang Ye <sub> <Email:yy@runchee.com> </sub>"
date: "Nov 09, 2017"
# runtime: shiny
---

```{r setup, include=FALSE}
library(tidyverse)
library(shiny)
library(lubridate)
library(bizdays)
library(fOptions)
library(ggplot2)
knitr::opts_chunk$set(echo = FALSE, fig.align="center", collapse = TRUE, cache = T)
chunk <- "```"
inline <- function(x = "") paste0("`` `r ", x, "` ``")
```

# Lecture 04: R catch-up
Let's review some R basics.

- Vector/Matrix/String/Date/Time
- Anonymous function
- List
- Environment
- Pipe
- Load/Save
- Data Frame

```{r, echo = FALSE, out.width = "15%"}
knitr::include_graphics("imgs/Rlogo.png")
```

# R: Vector
Vector/Matrix/List/Dataframe

```{r, echo = T}
# Create a vector from number
v <- c(1, 3)
v[1] <- 3
v
```

```{r, echo = T}
# repeat 100 for 10 times.
rep(100, 10)
```

# R: Matrix

```{r, echo = T}
# create matrix of 10x10
mat <- matrix(2, 3, 4)
mat
# set first row to 4
mat[1,] <- 4
# set element (2, 2) to 6
mat[2, 2] <- 6
```

# Find element in Vector
- `which()`
- `match()`
- `%in%`

```{r, echo = T}
data <- 10:1
match(c(1, 3), data)
data[match(c(1, 3), data)]
which(1 == data | 3 == data)
data[which(1== data | 3 == data)]
```

# Check whether element exists
- False case when element doesn't exist

```{r, echo = T}
match(c(11, 31), 10:1)
which(11== 10:1 | 31 == 10:1)
```

```{r, echo = T}
if (all(c(1, 33) %in% 1:3)) {
  cat("Found all\n")
}

if (any(c(1, 33) %in% 1:3)) {
  cat("Found one/some.\n")
}
```

# Random
```{r, echo = T}
# Norm random number
rnorm(3, mean = 10, sd = 3)
```

```{r, echo = T}
# Uniform random number
runif(3)
```

```{r, echo = T}
# Sample
sample(1:10, 10, replace = F)
# To Be/Not to Be
sample(c(T, F), 10, replace = T)
# Throw a dice
sample(1:6, 10, replace = T)
```

# Print
- `cat(paste0(..., "\n"))` is what I used most.
- `"\n"` is appended to the end to create a line break.
- `paste0/paste` can use to create new strings from any data types.
- `paste0` combines any thing without space. `paste` uses space, by default. 
- `paste0/paste` with `collapse` helps with vector to print them in one line.
- `paste0/paste` works with all types of data.

```{r, echo = T}
x <- c(Sys.Date(), Sys.Date(), Sys.Date())
cat(paste0("Current dates is ", x, ".\n"))
cat(paste0("Current dates is ", paste0(x, collapse = ", "), ".\n"))
```

# String

```{r, echo = T}
# sub-string
# substr(x, start, stop) 
substr("The fox jumps.", 6, 6 + 5 - 1)
```

```{r, echo = T}
# paste0/paste to concatenate string/convert to string
new_string <- paste0("This is ", "cat")
new_string <- paste0("This is ", "cat", sep = "a")
new_string <- paste0(1:3, sep = "a")
```

```{r, echo = T}
# toupper/tolower
toupper("big")
tolower("LOWER")
```

# Find/Replace string in string

```{r, echo = T}
# grepl: Find, returns T or F
grepl("A", "ABC", fixed = T)
grepl("D", "ABC", fixed = T)
```

```{r, echo = T}
# sub: replace for one time
# sub(pattern, replace, string,...)
# fixed = T means use fixed string. Not regular expression
sub("D", "ABC", "DDD", fixed = T)
# gsub: replace for all
gsub("D", "ABC", "DDD", fixed = T)
```

# Find/Replace String with Regular Expression (RE)
If you start to use regular expression, sub/grepl becomes super powerful.
```{r, echo = T}
# If we need to find `Start` appearing the beginning of the string
grepl("^Start", "Start with me")
grepl("^Start", "me Start")
```

```{r, echo = T}
# To find something in the end
sub("X$", "Z", "XYZ ends with X")
```

# Match/Extraction with Regular Expression (RE)
## Match (RE)
```{r, echo = T}
sub("[^\\_]+\\_.*", "", "USDCNY_M1")
```
- `[^\\_]`: Character not containing `_`. Because _ is a special character, we quote it with two backslashes.
- `+`: One or more 
- `.`: Any character
- `*`: none or more.

# Match/Extraction with Regular Expression (RE)
## Extraction (RE)
```{r, echo = T}
# Rough cut
sub("([^\\_]+)\\_.*", "\\1", "USDCNY_M1")
```

```{r, echo = T}
# Nice cut
sub("([^\\_]+)\\_(.*)", "\\1 \\2", "USDCNY_M1")
```

```{r, echo = T}
# Wonderful cut
sub("([^\\_]+)\\_([[:alpha:]])([[:digit:]])", "\\1 \\2 \\3", "USDCNY_M1")
```

Cheatsheat is available at <https://www.rstudio.com/resources/cheatsheets/>

# Date

```{r, echo = T}
# Create date
dt1 <- as.Date("2017-11-03")
dt1
dt2 <- Sys.Date()
dt2
```

```{r, echo = T, results = "hide"}
library(lubridate)
```

```{r, echo = T}
# Date is such a central role in finance.
# More function about date can be found in package `lubridate`
# Create date with lubridate, a package which provides lots of date functions.
ymd(20171003)
ymd("20171003")
```

# Date: format code
We can use codes for convert date to/from string.

- %Y/%y: four-digit year/two-digit year
- %m: month in number
- %b/%B: month in abbreviation/full, i.e. Jan/January.
- %d: day

```{r, echo = T}
format(Sys.Date(), format = "%Y/%m/%d")
```

```{r, echo = T}
as.Date("2017-11-03", format = "%Y-%m-%d") # %m for number month
as.Date("2017-Nov-03", format = "%Y-%b-%d") # %b for the 3-letter month
as.Date("03Nov2017", format = "%d%b%Y")
```

# Other functions from `lubridate`

```{r, echo = T}
library(lubridate)
# Change a date
x <- as.Date("2017-10-10")
month(x) <- 1
x
```

```{r, echo = T}
# Set to the end of the month
day(x) <- days_in_month(x)
```

# Business days
Use package `bizdays`

```{r, echo = T, results = "hide"}
# install.packages("bizdays")
library(bizdays)
```

```{r, echo = T}
# 'weekends' is a calendar of weekdays
bizdays("2017-10-16", "2017-10-30", "weekends")

# add bizdays
add.bizdays("2017-11-03", 5, "weekends")

# generate all business days between.
# You will find this useful for later financial application.
bizseq("2017-11-10", "2017-12-01", "weekends")
```

# Calendar

If not provided, start.date is by default the first holiday and end.date is the last holiday.
So we provide them here.

```{r, echo = T}
create.calendar(name="Singapore", holidays = c(as.Date("2017-10-18")),
                start.date = as.Date("2017-01-01"), end.date = as.Date("2071-01-01"),
                weekdays = c("saturday", "sunday"))

bizdays("2017-10-13", "2017-10-30", "weekends")
# One day less
bizdays("2017-10-13", "2017-10-30", "Singapore")
```

# Write function
Input parameters

```{r, echo = T, results = "hide"}
func1 <- function() { }

func2 <- function(input1, input2) { }

# Param input1 is default to 1
func3 <- function(input1 = 1, input2) { }

func4 <- function(input1, input_type = c("int", "char"))
{
  # This would check wheher input_type is set to one of the pre-set values.
  input_type = match.arg(input_type) 
}

func5 <- function(in1, in2) {
  if (in1 < 0) {
    return(0)
  } else {
    return(in1 + in2)
  }
}
```

# Write function

```{r, echo = T, results = "hide"}

# The last value before function finishes will be returned automatically. No need to use return.
func5 <- function(in1, in2) {
  if (in1 < 0) {
    0
  } else {
    in1 + in2
  }
}

# Unless there is extra steps before
func6 <- function(in1, in2) {
  if (in1 < 0) {
    return(0) # if we have 0 here, it's not the last step before function exits.
  } else {
    res <- in1 + in2
  }

  res <- res * 3
  res
}
```

# Exercise
Write functions to do

- Determine leap year?
- Print the list of month names in abbreviation or full
- How many working days in Singapore in 2017?

# Time
Convert time to character/string

- %H: hour
- %M: minute
- %S: second

```{r, echo = T}
format(Sys.time(), format = "%H%M")
format(Sys.time(), format = "%H:%M:%S")
format(Sys.time(), format = "%H:%M:%S")
library(lubridate)
ymd_hms("2011-12-31 12:59:59")
```

Change time, lubridate provides `hour`, `minute`

```{r, echo = T}
x <- Sys.time()
x
hour(x) <- 12
x
minute(x) <- 3
x
minute(x) <- 123 # what will happen?
x
```

# List
```{r, echo = T}
# Create list with list() function
# Nameless list
# list[_n_] => item by order
a <- list(3, 4)
a[[1]]
a[[2]]

# Named list, you can use $ and [ operators
# list[[]]: gives back a value
# list$name => list[["name"]]
a <- list(a = 3, b = 4)
a[[1]]
a[[2]]
a[["a"]]
a$a

# When you want to use a number as key, use backtick
list_of_strikes <- list()
list_of_strikes$`65` <- 3
list_of_strikes$`60` <- 4

# if a name doesn't exist in the list
a$c
# Use `is.null()` to check
if (is.null(a$c)) {
  cat("c doesn't exist in list a\n")
}
```

# List's Usage - 1

```{r, echo = T}
# List can be used as map/dictionary.
# Map
basket <- sample(c("Apple", "Orange", "Pear"), 100, replace = T)
fruit_count <- list()
for (b in basket) {
  if (is.null(fruit_count[[b]])) {
    fruit_count[[b]] <- 1
  } else {
    fruit_count[[b]] <- fruit_count[[b]] + 1
  }
}
fruit_count
```

# List's Usage - 2

```{r, echo = T}
# Let's write a generic function to do this
add_to_map <- function(map, key, value) {
  if (is.null(map[[key]])) {
    map[[key]] <- value
  } else {
    map[[key]] <- map[[key]] + value
  }
  map
}

# You may copy function add_to_map to every file that you want to use this kind of dictionary
fruit_count <- add_to_map(fruit_count, "Pomelo", 12)
fruit_count
```
# List's Usage

```{r, echo = T}
# Use case 1: Use list to pass data in or out.
do_lots_of_work <- function(a, b, c) {
}
# pass in
do_lots_of_work <- function(lst) {
  lst$a + lst$b
}
# pass out
ret_lots_of_work <- function() {
  return(list(a = a, b = b))
}

res <- ret_lots_of_work()
res$a
res$b
```

```{r, echo = T}
# Case 2: configuration
app_config <- list(MAX = 10, MIN = 10, DISPLAY_RESULT = T)

do_lots_of_work <- function(app_config) {
  app_config$MAX
}
```

# Object
```{r, echo = T}
# Object
# Define class with attributes.
vanilla_option <- setClass("vanilla_option",
                           slots = c(type = "character",
                                     strike = "numeric",
                                     underlying = "numeric"))
# Create object, either way
opt1 <- new("vanilla_option", type = "c", strike = 100, underlying = 100)
opt2 <- vanilla_option(type = "c", strike = 100, underlying = 100)

# Use @ to visit member. or,
opt1@type
slot(opt1, "strike")
```

# Work with objects
```{r, echo = T, cache = T}
# Generate a vector of options
opts <- sapply(1:10000, function(x) { 
                       vanilla_option(type = sample(c("c", "p"), 1),
                                      strike = round(runif(1) * 100, 0),
                                      underlying = round(runif(1) * 100, 0)) } )

# install.packages("fOptions")
library(fOptions)

start <- Sys.time()
# GBSOption also returns an object. We just need its price attribute.
res1 <- sapply(opts, function(o) {
  (GBSOption(o@type, o@underlying, o@strike, Time = 1,
             r = 0.01, b = 0, sigma = 0.3))@price
})
cat(as.numeric(Sys.time() - start))
head(res1, n = 4)

# Alternatively to sapply, we can use map* functions from purrr package
# map is a generic function that returns a list
# map_dbl is for result of double, it would return a vector
res2 <- purrr::map_dbl(opts, function(o) {
  (GBSOption(o@type, o@underlying, o@strike, Time = 1,
             r = 0.01, b = 0, sigma = 0.3))@price
})
head(res2, n = 4)
```

# Anonymous Function

```{r, echo = T}
# Function that's defined in-place, which doesnt' need to have a name.
(function(x) { print(x) }) (3)
# if there is only one line, you can skip { }
(function(x) print(x)) (3)

# For longer functions, you can make it multi-lines.
(function(x) {
  if (x > 3) {
    print(x)
  } else {
    print(x - 3)
  }
})(3)
```

# purrr::map and sapply Function
```{r, echo = T}
# These two are equivalent.
res1 <- purrr::map(1:10, function(x) { rnorm(x, n = 10) })
# function(x) func(x) can be simplied as func.
res2 <- purrr::map(1:10, rnorm, n = 10)
head(res1, n = 1)
# purrr:map returns a list()
```
```{r, echo = T}
# This is what we really want to do. Generate ten normal distribution and get their mean.
# rnorm(n, mean = 0, sd = 1). Where doesn't input go to?
res <- purrr::map(1:10, rnorm, n = 1000)
map_dbl(res, mean)

# sapply achieves the same as purrr::map, a bit slower.
# Package purrr succeeds original R base.
sapply(1:10, function(x) x ^ 2 )
sapply(1:10, function(x) `^`(x, 2) )
sapply(1:10, function(x) `^`(2, x) )
```

# Read/Write data

    # set working directory
    setwd("C:/TEMP")
    # Save this_is_var1 to a file
    saveRDS(this_is_var1, file = "C:/TEMP/DATA/data.Rds")
    # Load a variable from a file. `new_loaded` is the name given to it.
    new_loaded <- readRDS(file = "C:/TEMP/DATA/data.Rds")

- On Windows, use double slashes `\\` or single backslash `/`. e.g. `C:\\TEMP\\DATA`, `C:/TEMP/DATA`
- On Mac, use backslash `/Users/.../`

# R: data frame
The basic structure of a data frame:

- There is one observation per row and
- Each column represents a variable, a measure, feature, or characteristic of that observation. 
- In summary, **2D table**

```{r, echo = T}
df <- data_frame(date = seq(as.Date("2017-01-01"), as.Date("2017-01-10"), by = "day"),
                 stock = replicate(10, paste0(sample(LETTERS, 3, replace = T), collapse = "")),
                 quantity = round(runif(10) * 10000 ,0))
# df["date"]: gives a data frame
# df[["date"]]: gives value
# df$date: same as [["date"]]

# Get three rows
df[c(3, 6, 9), , drop = F]
```

```{r, echo = T}
# Get three columns
df[, 1, drop = F]
# This would return a vector
df[, 1, drop = T]

# Use column names
df[, c("date", "quantity"), drop = F]
```

# R: data frame
Common functions for data frame

    View()
    head()
    tail()
    str()
    nrow()
    ncol()
    dim() # returns both nrow and ncol
    colnames()/rownames()

# Birthday Problem
- With different weights to the month
- N simulation

```{r, echo = F, cache = TRUE}
sample_bday <- function(dummy) {
  a <- trunc(runif(365, min=1, max=13))
  bday <- rep(FALSE, 12)
  nn <- 0
  for (ii in a) {
    nn <- nn + 1
    if (!bday[ii]) bday[ii] <- TRUE
    if (sum(bday) == 12) break
  }
  nn
}
result <- sapply(seq(1:1000), sample_bday, simplify = TRUE)

print(min(result))
print(max(result))
print(mean(result))
hist(result, xlim=c(0,100), freq=3)
# 12 207 37.23126
```

# Fastest Fish Problem

```{r, echo = F, cache = T}

N <- 10

survi <- function() {
  queue <- sample(1:N, N, replace = F)
  qori <- queue
  fastest <- queue[1]
  for (n in 2:N) {
    if (queue[n] > fastest) {
      queue[n] <- NA
    } else {
      fastest <- queue[n]
    }
  }
  list(qori = qori,
       queue = queue)
}

# plot((survi())$queue, 1:10, col = "skyblue2", pch = "\u2653", cex = 2)

plot(1:10,1:10,type="n")
res <- survi()
for (i in 1:10) {
  if (is.na(res$queue[i])) {
    text(res$qori[i], i, paste0("\u2653 ",i), col = "grey", cex = 1.4) 
  } else {
    text(res$queue[i], i, paste0("\u2653 ",i), col = "skyblue3", cex = 1.8)
  }
}

sim_sample <- replicate(10000, length(na.omit({ survi()$queue })))
res_sim <- mean(sim_sample)

survi.prob <- function() {
  sum <- 0
  for (n in 1:N) {
    sum <- sum + 1/n
  }
  sum
}
res_ana <- survi.prob()

cat(paste("res_sim:", res_sim, "\n"))
cat(paste("res_ana:", res_ana, "\n"))
hist(sim_sample)
```

# Lecture 05: Shiny

# Minimalist
    
    library(shiny)
    ui <- fluidPage("Hello World")
    server <- function(input, output, session) { }
    shinyApp(ui = ui, server = server)

# Think around Input and Outputs

    ui <- fluidPage(
      titlePanel("Hello World with a Histogram"),
      # Input() functions
      numericInput("num", "Number of Sample", value = 30),
      # Output() functions
      plotOutput("hist")
    )


# Input

All input function follow such function signature except for input-specific parameters.

    inputXXX(inputId = "input name", label = "label to display", ...)

- numericInput
- textInput
- passwordInput
- slideInput
- selectInput
- dateInput

Reference: https://shiny.rstudio.com/reference/shiny/1.0.5/

# Output

All output function follow such pattern.

    yyyOutput(outputId = "output name")

- textOutput("text")
- verbatimTextOutput("text_orignal")
- tableOutput("t1")
- dataTableOutput("t2")
- plotOutput(outputId = "hist", width = "400px", height = "400px")
- uiOutput("uiX")

plotOutput: I suggest to set width and height to fixed size so we need extra parameters.
For others, outputId is good enough.

# Server
Sever is to fill the content of output

    server <- function(input, output, session) {
      # Enable either one of two
      output$hist <- renderPlot({ hist(rnorm(100)) })
      
      if (FALSE) {
        output$hist <- renderPlot({
          title("a normal random number histogram")
          hist(rnorm(input$num))
        })
      }
    }

## shinyApp = UI + Server
UI and Server combines to be a ShinyApp.
UI is to run the same for each browser/client.
Server is separate between different users.

    shinyApp(ui, server)

# Reactivity Kicks In
- Reactivity: `input$num ------> output$p1`
- Reactivity links input to the output like a data flow.

Reactive values work together with reactive functions.

1. Reactive function responds. `input$x => output$y`
2. Reactive value notifies. `input$x => expression() => output$y`

# Reactivity - 1
Reactivity is enabled by placing inputXXX in renderXXX function.

```{r echo = FALSE, comment = ""}
cat(htmltools::includeText("example/shiny-21.R"))
```

# Reactivity - 2
- We use `observeEvent` to observe button action, and `isolate` to cut down the link of `inputXXX` in `renderXXX`, so button can work.
- If we remove `isolate`?

```{r echo = FALSE, comment = ""}
cat(htmltools::includeText("example/shiny-22.R"))
```

# Reactivity - 3
We can add a reactiveValue with `eventReactive`

```{r echo = FALSE, comment = ""}
cat(htmltools::includeText("example/shiny-23.R"))
```


# Output

For tableOutput

    output$t1 <- renderTable(iris)
    
    output$t1 <- renderTable({
      some input..
      output is a data frame.
    })

For dataTableOutput (Dynamic table)

    output$t2 <- renderDataTable(iris)

For plotOutput
    
    output$p2 <- renderPlot({ plot(runif(1000), runif(1000)) })

For textOutput and verbatimTextOutput

    output$t3 <-  renderText({ "foo" })
    output$t4 <- renderPrint({
      print("foo")
      print("bar")
    })

For uiOutput, next week

# Example: Shiny-24

```{r echo = FALSE, comment = ""}
cat(htmltools::includeText("example/shiny-24.R"))
```

# Debug Shiny
- Debug in R Studio
- Clear all variable to run Shiny in R Studio
- debugSource, if you use other source code

        tryCatch({
          
        }, error = function(e) {
          print(error)
        }, warn = function(w) {
          print(w)
        })
    
# Summary
## Assignment
- Reactive is about wiring input and output
- Connect from receiver: plot/tabulate for data
- Connect from trigger: button, isolate to create a Chinese wall

## Assignment
1. Add a selectInput for different color names, returned from `colors()`.
    
    plot(1:10, pch = 19, cex = 1, col = "skyblue1")

2. Create a Bond Schedule
  + Inputs: start date, tenor, coupon rate, yield to maturity.
  + Output: coupon schedule (ignore public holidays), amount in table and plot.
            NPV
  
$NPV = \frac{Cashflow 1}{(1 + yield)^1} + \frac{Cashflow 2}{(1 + yield)^2} + ... + \frac{Last Cashflow}{(1 + yield)^n}$

For a Bond with fixed coupon
$Bond Price = Coupon * \frac{1 - (\frac{1}{(1 + yield)^n})}{yield} + \Big[MaturityValue * \frac{1}{(1 + yield)^n}\Big]$

# Lecture 06: Data

# tidyverse

Library dplyr::lag may cause a conflict to stats::lag.
Use dplyr::lag when it doesn't work.

# SQL

Let's start from SQL.

SELECT * FROM table WHERE a = 3

SELECT * FROM table WHERE a = 3 ORDER BY a

SELECT b, sum(a) FROM table WHERE a = 3 GROUP BY b

INSERT into table (a, b, c, ...) VALUES ("a", "b", "c", ...);

UPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition;

DELETE from table WHERE a = 3

# CRUD: Create Read Update Delete

<center>![](imgs/CRUD.png "CRUD"){width=45%}</center>

# Apply CRUD operations to data frame.

Select:
df[which(df$a == 3 | df$b == 3), , drop = T] 
df[match(3, df$a), , drop = T]

df[, match("city", colnames(df)), drop = T] 

Insert:
rbind(df, df)

Delete:
df[-(which(df$a == 3 | df$b == 3)), , drop = T]

Update:
df[which(df$a == 3 | df$b == 3), 3, drop = T] <- 3

# dplyr
dplyr package from tidyverse is a high-performance package to deal with data frame.

dplyr provides functions in "verbs". Some of them are:

- select: return a subset of the columns of a data frame, using a flexible notation
- filter: extract a subset of rows from a data frame based on logical conditions
- arrange: reorder rows of a data frame
- rename: rename variables in a data frame
- mutate: add new variables/columns or transform existing variables
- %>%: the “pipe” operator is used to connect multiple verb actions together into a pipeline
- group_by / rowwise / ungroup: stratify the data
- summarise / summarize: generate summary statistics of different variables in the data frame, possibly within strata
- do: process data within the strata
- left_join / right_join / anti_join / full_join
- bind_rows / bind_cols
- ifelse / case_when
- lag

# sample dataset
http://dx.doi.org/10.1016/j.dss.2014.03.001

<center>![](imgs/sample-bank-data.png "Sample Bank Data"){width=45%}</center>


# Sample dataset columns

   1 - age (numeric)
   2 - job : type of job (categorical: "admin.","unknown","unemployed","management","housemaid","entrepreneur","student",
                                       "blue-collar","self-employed","retired","technician","services") 
   3 - marital : marital status (categorical: "married","divorced","single"; note: "divorced" means divorced or widowed)
   4 - education (categorical: "unknown","secondary","primary","tertiary")
   5 - default: has credit in default? (binary: "yes","no")
   6 - balance: average yearly balance, in euros (numeric) 
   7 - housing: has housing loan? (binary: "yes","no")
   8 - loan: has personal loan? (binary: "yes","no")
   # related with the last contact of the current campaign:
   9 - contact: contact communication type (categorical: "unknown","telephone","cellular") 
  10 - day: last contact day of the month (numeric)
  11 - month: last contact month of year (categorical: "jan", "feb", "mar", ..., "nov", "dec")
  12 - duration: last contact duration, in seconds (numeric)
   # other attributes:
  13 - campaign: number of contacts performed during this campaign and for this client (numeric, includes last contact)
  14 - pdays: number of days that passed by after the client was last contacted from a previous campaign (numeric, -1 means client was not previously contacted)
  15 - previous: number of contacts performed before this campaign and for this client (numeric)
  16 - poutcome: outcome of the previous marketing campaign (categorical: "unknown","other","failure","success")

  Output variable (desired target):
  17 - y - has the client subscribed a term deposit? (binary: "yes","no")

# What are the data attributes?


# Read the data
Use RStudio's File -> Import Dataset, you may choose either "From Text (base)" or "From Text (readr)". Either way loads the data.
base comes with R installation. `readr` is a package that provides more options and functionality.
Copy the generated code to your script file.

base

    bank <- read.csv("../example/data-bank/bank.csv", sep=";")
    bank <- read.csv("https://goo.gl/PBQnBt", sep = ";")

readr

    library(readr)
    bank <- read_delim("../example/data-bank/bank.csv", 
                       ";", escape_double = FALSE, trim_ws = TRUE)
    View(bank)

Reference:
R for Data Science, chapter 11.
<http://r4ds.had.co.nz/data-import.html>

# select

subset <- select(bank, marital)
subset <- select(bank, 1)
subset <- select(bank, -1)
subset <- select(bank, -(job:education))
subset <- select(bank, -job)
subset <- select(bank, starts_with("p"))
subset <- select(bank, ends_with("p"))
subset <- select(bank, contains("p"))
subset <- select(bank, matches("(.)\\1"))
subset <- select(bank, num_range("x", 1:3))

## Select as a re-arrangement of columns.
select <- select(bank, job, everything())

# filter
young <- filter(bank, age < 20 & marital == "married")
young <- filter(bank, age < 20 & marital == "single")
young <- filter(bank, age < 20)

young2 <- filter(bank, age >= 20 & age < 30 & marital == "married")
young2 <- filter(bank, age >= 20 & age < 30 & marital == "single")
young2 <- filter(bank, age >= 20 & age < 30)

%in%

|

```{r, echo = FALSE, out.width = "75%"}
knitr::include_graphics("imgs/transform-logical.png")
```

filter out NA value.
filter(df, is.na(x) | x > 1)

sum(x, na.rm = T)

sqrt(2) ^ 2 == 2
near(sqrt(2) ^ 2, 2)

1/49 * 49 == 1
near(1/49 * 49, 1)

How many bank client have a loan while doesn't have a housing?
How many bank client have a job between 20 to 40?

# rename
raname(bank, Age = age)
raname(bank, `Age in Bank` = age)

# arrange
arrange(bank, job)
arrange(bank, default, job)

arrange(bank, desc(day))
arrange(bank, desc(as.Date(day, format="%d", origin = Sys.Date())))

NB: Missing values are always sorted at the end.

- How could you use arrange() to sort all missing values to the start? (Hint: use is.na()).

    arrange(bank, !is.na(a), a)

- Find the longest duration?
- Find the eldest?

# mutate
Add a new column.

  df1 <- mutate(bank, y = ifelse(y == "yes", T, F))
  df2 <- mutate(bank, duration_diff = duration - mean(duration, na.rm = TRUE))

  mutate(bank, age_group = case_when(
    age < 20 ~ "youth",
    age < 40 ~ "middle-age",
    age < 50 ~ "senior",
    TRUE ~ "happy"
  ))

  # month.abb is a built-in array of month names.
  mutate(bank, month = factor(firstup(bank$month), levels = month.abb))

transmute would remove all other columns after mutation, only keeping the new variable.
  df3 <- transmute(bank, 
                   duration_trend = duration - mean(duration, na.rm = TRUE),
                   balance_trend = balance - mean(balance, na.rm = TRUE)))

# What you can do with mutate
## +, -, *, /:
## %/% (integer division) and %% (remainder), where x == y * (x %/% y) + (x %% y)
## apply this to ungroup df.
x / sum(x)
y - mean(y) computes the difference from the mean.
## log2(), log(), log10()
## lead(), lag()
compute running differences (e.g. x - lag(x)) or find when values change (x != lag(x))
## rolling sum, prod, min, max
cumsum(), cumprod(), cummin(), cummax(); and dplyr provides cummean()
## rank
y <- c(1, 2, 2, NA, 3, 4)
min_rank(y)
min_rank(desc(y))

row_number(y)
#> [1]  1  2  3 NA  4  5
dense_rank(y)
#> [1]  1  2  2 NA  3  4
percent_rank(y)
#> [1] 0.00 0.25 0.25   NA 0.75 1.00
cume_dist(y)
#> [1] 0.2 0.6 0.6  NA 0.8 1.0

# operators

# %>%
%>% is from library(dplyr) tidyverse) to use previous result. We will talk about it later.

third(second(first(x)))
This nesting is not a natural way to think about a sequence of operations. The %>% operator allows you to string operations in a left-to-right fashion, i.e.

first(x) %>% second() %>% third()
x %>% first() %>% second() %>% third() # this could also do.
x %>% first(.) %>% second(.) %>% third(.) # . represents the input

What's the output of below?

```{r, echo = TRUE }
c(1, 3, 7, 9) %>% {
  print(.)
  mean(.)
} %>% { . * 3 } %>% {
  print(.)
  sample(round(., 0))
}
```

We don't need to keep intermediate result, sames memory and also variable names.
But the issues cames at debugging
- Use { print(.); filter(., ...) }
- separate the long pipes into shorter pipes, adding more intermediate variables.

- Your pipes are longer than (say) ten steps. In that case, create intermediate objects with meaningful names. That will make debugging easier, because you can more easily check the intermediate results, and it makes it easier to understand your code, because the variable names can help communicate intent.
- You have multiple inputs or outputs. If there isn’t one primary object being transformed, but two or more objects being combined together, don’t use the pipe.
- You are starting to think about a directed graph with a complex dependency structure. Pipes are fundamentally linear and expressing complex relationships with them will typically yield confusing code.

# Environment
Environment is where your data resides.

```{r, echo = T}
x <- 3
local({
  print(x)
  x <- 1
  print(x)
})
print(x)
```

```{r, echo = T}
x <- 3
{
  print(x)
  x <- 1
  print(x)
}
x
```

```{r, echo = T}
x <- 1
pass_out_global <- function() {
  assign("x", 3, envir = .GlobalEnv)  
}

pass_out <- function() {
  assign("x", 2, envir = parent.env(environment()))
}
```

```{r, echo = T}
x <- 1
pass_out()
x

extra_layer <- function() {
  pass_out()
}

x <- 1
extra_layer()
x

extra_layer_g <- function() {
  pass_out_global()
}

x <- 1
extra_layer_g()
x
```

# Pipe

%>% ... %>%

return multiple value

%>% {
  - assign parent.env
}  %>%

%>% {
  - list
}  %>%

# Code pattern with Pipe

    Df %>% ... %>%
    {
    ggplot() +

    Individual 
    Group
    }

# left_join / right_join / anti_join / full_join

| position_id | buy/sell | quantity | risk factor |

Suppose we have two days position data, suppose positions are additive (to close a position, we won't change the original position but to do a new reverse trade), they are of same structure

In order to find the new positions. We will use:
anti_join(new_data, old_data) # order matters, new_data needs to be placed first.

In order to find old positions, we will use:
inner_join(new_data, old_data) # regardless order, new_data is in front of old_data.
left_join(old_data, new_data) # produce the same result
right_join(new_data, old_data) # produce the same result

## full_join
find all combinations between table a and b.

# left_join/right_join
can be used to do mapping.

Table a:
| type_code | type_name |
| 1         | orange    |
| 2         | banana    |

Table b:
| type_code | quantity | customer_id |
| 1         | 1        | A           |
| 2         | 3        | B           |
| 3         | 4        | C           |
| 2         | 2        | D           |
| 1         | 6        | B           |

table c:
| customer_id | customer_phone |
| A           | +123           |
| B           | +456           |
| C           | +789           |

left_join(b, a, by = "type_code") %>% left_join(c, by = "customer_id")

| type_code | quantity | customer_id | type_name | customer_phone |
| 1         | 1        | A           | orange    | +123           |
| 2         | 3        | B           | banana    | +456           |
| 3         | 4        | C           | NA        | +789           |
| 2         | 2        | D           | banana    | NA             |
| 1         | 6        | B           | orange    | +456           |

join can be multiple types

# bind_rows / bind_cols

# Plot
dev.new(width=4, height=4)
with(bank, plot(balance, duration, type = 'n'))
with(bank, text(balance, duration, education, col=cl))
group_by(bank, cl) %>% summarise(n = n())

# group_by
bank1 <- group_by(bank, age) %>%
  summarise(balance_mean = mean(balance),
            count = n(),
            default_count = sum(ifelse(default == "no", 0, 1)))

## If combined with ggplot, to be learnt in next session
ggplot(bank1, aes(x = age, y = balance_mean)) +
  geom_point(aes(size = count), alpha = 1/4, color = "red") +
  geom_point(aes(size = default_count), alpha = 1/3, color = "blue") +
  geom_smooth(se = F)

# summarise functions
## mean(x), but median(x)
mean(age[balance > 0])
mean(age[balance < 0])
# sd(x), IQR(x), mad(x)
sd(distance)
# min(x), quantile(x, 0.25), max(x)
# n(): count / n_distinct()
# first(x), nth(x, 2), last(x)
# count for condition
sum(balance < 500)): TRUE => 1, FALSE => 0
sum(x > 10), mean(y == 0)

I often forgot there are existing functions that resort to longer versions.

# group filter
Find the maximum and minimum balance on each age.
bank %>% 
  group_by(age) %>%
  filter(rank(balance) == 1 | rank(desc(balance)) == 1) %>%
  arrange(age, balance)

Find the big age group
bank %>% 
  group_by(age %/% 10) %>%
  filter(n()/nrow(bank) > 0.2) %>%
  arrange(age)

ungroup() removes strata, restores the data frame back to entire rows.

chicago <- mutate(baml, year = as.POSIXlt(date)$year + 1900)
> summarize(years, pm25 = mean(pm25, na.rm = TRUE), 
+           o3 = max(o3tmean2, na.rm = TRUE), 
+           no2 = median(no2tmean2, na.rm = TRUE))

> qq <- quantile(chicago$pm25, seq(0, 1, 0.2), na.rm = TRUE)
> chicago <- mutate(chicago, pm25.quint = cut(pm25, qq))

> quint <- group_by(chicago, pm25.quint)
Finally, we can compute the mean of o3 and no2 within quintiles of pm25.

> summarize(quint, o3 = mean(o3tmean2, na.rm = TRUE), 
+           no2 = mean(no2tmean2, na.rm = TRUE))

# mutate with style

    ungroup() %>%
    mutate(nnn = 1:n()) %>%
    mutate(x = tryCatch({
        as.Date(x)
    })

group_by/rowwise/ungroup

# grouped or ungrouped
    
    ungroup(df) %>% mutate( x = ifelse( x == "ABC", "is ABC", "not ABC" ) )
    group_by(x) %>% summarise( cc = count(x) )

# summarise without a group_by
Just cover entire dataset.

    summarise( x = sum(ifelse( x == "ABC", 1, 0 ) )
  min()
  max()
  n = n()
  mean()

# rowwise
Use if. ifelse is restrictive that it only output the same type as the input.

    rowwise(df) %>% mutate( x = { if ( x == "ABC" ) { "is ABC" } else { "not ABC" }  } )

# summarise
 example: how to get sub-total and total.

# do
do. with an index column and do the analysis for the rest.

CRUD:

Create:
- add a column for rownumber.
- discover insights of data.
- retrieve with age, slider of numeric
- employment
- Social attributes.
- count for subtotal - total, plot graph

D:
Mark for not included in the 

C:
Add new.

U:

# Rules of Thumb for design data storage
* Use list to store app data, i.e. configuration.
* User data frame to store user data.
* You need column **item_id** to put into every_table. It can be number or character. Make it unique. So you need to keep the current highest number in another place.
* Delete is not good for customer data. add a column name with a common name, e.g. SYS_DEL.

| position_id | call_put | amount | strike | SYS_DEL |
| X123        |          |        |        |

* Market 

# Assignment
* Book option trades
* https://finance.google.com/finance/option_chain?q=NASDAQ%3AAMZN&ei=iIoAWvDmF8GqugSsj5mICw
* Date | Strike | Quantity | Underlying | Long/Short | Call/Put
* 
* Book bank transactions
* Book option trade transactions