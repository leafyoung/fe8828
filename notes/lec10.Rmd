---
title: "FE8828 Programming Web Applications in Finance"
subtitle: "<sub> Week 4 <br> Data, visualization, and web: part 3 </sub>"
author: "Dr. Yang Ye <sub> <Email:yy@runchee.com> </sub>"
date: "Nov 23, 2017"
# runtime: shiny
---

# Lecture 8: Viz

`library(ggplot)`

## ggplot
```{r, echo = FALSE, out.width = "75%"}
knitr::include_graphics("imgs/main-qimg-bf859b506013fd60589a28be4c3f9e47.png")
```
ggplot(data = <DATA>, ...) + 
  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))

Put the + sign in the end of the line, not the beginning of the line.

WRONG
~~ggplot(data = <DATA>, ...)~~
~~+ <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))~~

# ggplot system

library(ggplot2)
ggplot(airquality, aes(Temp, Ozone)) + 
        geom_point() + 
        geom_smooth(method = "loess", se = FALSE)

# simply plot x and y
qplot(age, balance, data = bank)
qplot(age, balance, data = bank, color = job)

# for non-numeric data
qplot(default, age, data = bank)
qplot(age, default, data = bank)
qplot(job, age, data = bank)

# add a geometry
qplot(age, balance, data = bank, geom = c("point", "smooth"))
qplot(age, balance, data = bank, color = job, geom = c("point", "smooth"))

# density
qplot(balance, data = bank, fill = job, geom = "density")
qplot(duration, data = bank, fill = job, geom = "density")
qplot(age, data = bank, color = job, geom = "density")
v.s.
qplot(age, data = bank, fill = job, geom = "density")
qplot(age, data = bank, color = job, fill = job, geom = "density")

# boxplot
qplot(job, duration, data = bank, geom = "boxplot")
qplot(job, balance, data = bank, geom = "boxplot")
qplot(job, age, data = bank, geom = "boxplot")

# Facets
qplot(pdays, data = bank, facets = job ~ ., binwidth = 2) # doesn't look great because we have so many jobs.
qplot(pdays, data = bank, facets = . ~ job, binwidth = 2) # not a good measure.
qplot(campaign, data = bank, facets = . ~ job, binwidth = 2)
qplot(duration, data = bank, facets = . ~ job, binwidth = 2)
qplot(balance, age, data = bank, facets = . ~ job)
qplot(age, balance, data = bank, facets = . ~ job)
qplot(age, balance, data = bank, facets = . ~ job) + geom_smooth()

Which is equivalent to
qplot(age, balance, data = bank, facets = . ~ job, geom = c("point", "smooth"))
qplot(age, balance, data = bank, facets = . ~ job, geom = "smooth")

# fill/color/shape can be each on one dimension of the data.
qplot(age, balance, data = bank, shape = marital, color = marital) + geom_smooth()
qplot(age, balance, data = bank, shape = job, color = marital) + geom_smooth()


Things to consider:

Which variables in mpg are categorical? Which variables are continuous?

- bio:
    + age
    + job
    + marital
    + education
- financial
    + default
    + balance
    + housing
    + loan
- communication
    + contact: celluar v.s. telephone v.s. unknown
    + day/month: maybe good to ignore?
    + duration:
    + campaign:
    + pdays:
    + previous:
    + poutcome:


# Insights Question
```{r}
qplot(age, job, data = bank, color = loan, shape = loan)
```

# Which data is good to use?
qplot(previous, data = bank, facets = . ~ job, binwidth = 2)
v.s.
qplot(previous, data = bank, facets = . ~ marrital, binwidth = 2)

# ggplot2
Level 2

g <- ggplot(bank, aes(x = age, y = duration))

# Each + is a layer
g + geom_smooth()
g + geom_point() + geom_smooth()

To combine we have, g is for re-use
ggplot(bank, aes(x = age, y = duration)) + 
  geom_point() + geom_smooth()

g + geom_point() + geom_smooth(method = "lm") + facet_grid(. ~ job)
g + geom_point(color = "steelblue", size = 4, alpha = 1/2)
g + geom_point(aes(color = job), size = 4, alpha = 1/2)
g + geom_point() + geom_point(aes(color = job), size = 4, alpha = 1/2) # each + is a layer

# Use the categorical variable to differtiate between different groups.

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class))

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, size = class))

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))

ggplot(data = mpg) + 
  geom_line(mapping = aes(x = displ, y = hwy, group = class))

## you can also enforce
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")

# histogram
ggplot(data = bank, mapping = aes(x = duration, fill = job)) + geom_histogram(binwidth = 2)
ggplot(data = bank, mapping = aes(x = duration, fill = job)) + geom_histogram(binwidth = 100)

ggplot(data = bank, mapping = aes(x = age, fill = job)) + geom_histogram(binwidth = 10)
ggplot(data = bank, mapping = aes(x = age, colour = job)) + geom_freqpoly(binwidth = 10)

# geom_bar: lowest granuity or
ggplot(data = bank, mapping = aes(x = age, colour = job)) + geom_bar()

# geom_bar: better serves for categorical data
ggplot(data = bank, mapping = aes(x = job, fill = education)) + geom_bar()
ggplot(data = bank, mapping = aes(x = job, fill = education)) + geom_bar() + coord_flip()
ggplot(data = bank, mapping = aes(x = reorder(job, age, FUN = mean), fill = education)) +
  geom_bar() +
  coord_flip()

ggplot(data = bank, mapping = aes(x = reorder(job, age, FUN = mean), fill = education)) +
  geom_bar() +
  scale_x_discrete(limit = rev(levels(reorder(bank$job, bank$age, FUN = mean)))) +
  coord_flip()



Levels gives more control to the layer and style.

cutpoints <- quantile(bank$age, seq(0, 1, length = 4), na.rm = TRUE)
# The age_group variable is now a categorical factor variable containing 3 levels, indicating the ranges of age.
bank$age_group <- cut(bank$age, cutpoints)
levels(bank$age_group)
g <- ggplot(bank, aes(age, duration)) +
     geom_point(alpha = 1/3) + 
     facet_wrap(job ~ age_group, ncol = 3) + # ncol = number of cuts 3 = length(levels(bank$age_group))
     geom_smooth(method="lm", se=FALSE, col="steelblue") + 
     theme_bw(base_family = "Avenir", base_size = 10) + 
     labs(x = "age", y = expression("log " * Duration)) + 
     labs(title = "Bank Clients")  
g

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2)

# ggplot with statistical transformation
ggplot(bank) + geom_bar(mapping = aes(x = age))
ggplot(bank) + geom_bar(aes(x = age)) # first input parameter to geom_bar is mapping, so we can skip it.
ggplot(bank) + geom_bar(mapping = aes(x = age, fill = job))

ggplot(bank) + geom_bar(mapping = aes(x = job))
ggplot(bank) +
  geom_bar(mapping = aes(x = job, fill = age)) # why this doesn't work. Age is a continous variable.

# Data with statistical
ggplot(data = bank) + 
  stat_summary(
    mapping = aes(x = age, y = balance),
    fun.ymin = min,
    fun.ymax = max,
    fun.y = median
  )

# Position for bar
ggplot(bank) + geom_bar(mapping = aes(x = age, fill = job), position = "dodge")
ggplot(bank) + geom_bar(mapping = aes(x = age, fill = job), position = "fill")

# Variations
ggplot(bank) + geom_bar(mapping = aes(x = age, fill = job), position = "fill") + coord_flip()
ggplot(bank) + geom_bar(mapping = aes(x = age, fill = job), position = "fill") + coord_polar()





# add theme
default theme is theme_gray()
g + geom_point(aes(color = job), size = 4, alpha = 1/2) + theme_bw()
g + geom_point(aes(color = job), size = 4, alpha = 1/2) + theme_times()

g <- ggplot(bank, aes(x = age, y = log(duration)))
g + geom_point(aes(color = job), size = 4, alpha = 1/2) + theme_bw()
g + geom_point(aes(color = job), size = 4, alpha = 1/2) + theme_bw() +
    labs(title = "Duration is longer with age",
         subtitle = "some random plot",
         caption = "from MFE") +
    labs(x = "age", y = expression("log " * Duration))


# Add themes
package ggthemes provides many classical themes.

## [1] "theme_base" "theme_calc"
## [3] "theme_economist" "theme_economist_white"
## [5] "theme_excel" "theme_few"
## [7] "theme_fivethirtyeight" "theme_foundation"
## [9] "theme_gdocs" "theme_hc"
## [11] "theme_igray" "theme_map"
## [13] "theme_pander" "theme_par"
## [15] "theme_solarized" "theme_solarized_2"
## [17] "theme_solid" "theme_stata"
## [19] "theme_tufte" "theme_wsj"

# ggplot summary
ggplot(data = <DATA>) + 
  <GEOM_FUNCTION>(
     mapping = aes(<MAPPINGS>),
     stat = <STAT>, 
     position = <POSITION>
  ) +
  <COORDINATE_FUNCTION> +
  <FACET_FUNCTION>

# ggplot: one more thing.
```{r echo = FALSE}
install.packages("maps")
nz <- map_data("nz")
ggplot(nz, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", colour = "black") +
  coord_quickmap()

world <- map_data("world")
ggplot(world, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", colour = "black") +
  coord_quickmap()
```


# model
models <- mtcars %>% 
  split(.$cyl) %>% 
  map(function(df) lm(mpg ~ wt, data = df))

models <- mtcars %>% 
  split(.$cyl) %>% 
  map(~lm(mpg ~ wt, data = .))

# model with Modelr

library(modelr)

mod <- lm(log(balance) ~ log(age), data = bank)

bank1 <- filter(bank, default == "no" & balance > 0)
mod <- lm(log(balance) ~ log(age), data = bank1)

bank2 <- bank1 %>% 
  add_residuals(mod) %>% 
  mutate(resid = exp(resid))

ggplot(data = bank2) + 
  geom_point(mapping = aes(x = age, y = resid))

# Question?
Age with respect to anything else.
With facets

# Lecture 9: Shiny

# Display output with `render*()` functions

- `render*()` arguments are code used to build and rebuild object
- `render*()` function re-runs the code with every change in the input

* Static table from df, mat, etc.s
    + renderTable()/tableOutput()
* Interactive table from data frame, matrix or other table-like structure
    + renderDataTable()/dataTableOutput() 
* Plot generated on-the-fly
    + renderPlot()/plotOutput() #
* Get continous output
    renderPrint()/verbatimTextOutput() or textOutput()
* Get last result
    renderText()verbatimTextOutput() or textOutput()
* Customized UI elements
    + uiOutput()/renderUI()

# render*
- Allow binding of one output to multiple inputs

    output$hist <- renderPlot({
      hist(data())
    })

    output$stat <- renderPlot({
      summary(data())
    })

```{r, echo = F}
# reactive()
# data <- reactive({
# hist(rnorm(input$num))
# })
```

# observeEvent
- Allow binding of multiple outputs to multiple inputs.
- Use of `isolate` to *peek* the value not to react to its change every time.

    actionButton(inputId = "go", label = "Click me")

    observeEvent(input$go, {
      # Use of isolate to *peek* the value not to react to it.
      num_input <- isolate(input$num_input)

      output$plot1 <- renderPlot({ 
        # if we use input$num_input here, we build a direct reactive link
        # between output$plot1 and input$num_input. This is not what we designed.
        plot(1:number_input, runif(num_input))
      })

      output$table1 <- renderTable({ ... })
    })

```{r, echo = F}
# observe() function
# observe({ print(input$go) }) reacts to whatever are changed in the code block.

# eventReactive() delay reactions
# mono-action to data binding
# data <- eventReactive(input$go, { rnorm(input$num) })
# button -> data -> renderPlot
# button -> renderPlot (direct is not very good)

# reactiveValues
# allow multiple binding of data to different input
# rv <- reactiveValues(data = rnorm(100))
# button -> change the data -> renderPlot
```

# When codes gets to run.
- ui: client. run once per user per session.
- server: run once per session
- code inside a reactive function runs with every input change.

# `renderUI`
- Dynamicaly creation of UI (user interface) with input and outputs.
- Append new items to tagList()

# Create dynamic output
```{r echo = FALSE, comment = ""}
cat(htmltools::includeText("example/shiny-34-renderUI.R"))
```

# Create dynamic output 2
You can use newly created UI immeidately
```{r echo = FALSE, comment = ""}
cat(htmltools::includeText("example/shiny-35-renderUI-2.R"))
```

# Create dynamic output 3
```{r echo = FALSE, comment = ""}
cat(htmltools::includeText("example/shiny-32-renderUI.R"))
```

# Create dynamic input 4
uiOutput("h1")
output$h1 <- renderUI({
  tagList(
    sliderInput("n", "N", 1, 1000, 500),
    textInput("label", "Label")
  )
})

# Update various input values
updateSelectionInput(...)
updateNumericInput(...)

# Dynamic input and `update***Input`
```{r echo = FALSE, comment = ""}
cat(htmltools::includeText("example/shiny-36-update.R"))
```

# ggplot/gridExtra
If we need to generate multiple plots. ggplot has a companion package to arrange plots. 

SxS: side by side
```{r, echo = T}
p1 <- ggplot(bank) + geom_bar(mapping = aes(x = age, fill = job), position = "fill") + coord_polar()
p2 <- ggplot(bank) + geom_bar(mapping = aes(x = age, fill = education), position = "fill") + coord_polar()
grid.arrange(p1, p2, ncol=2, nrow=1)
grid.arrange(p1, p2, ncol=2, nrow=1, widths = c(4,2))
grid.arrange(p1, p2, ncol=1, nrow=2, heights = c(4,2))
```

# ggplot/gridExtra
a bit more complicated
```{r, echo = T}
library(tibble)
library(ggplot2)
library(gridExtra)

df <- tibble(x = rnorm(100), y = rnorm(1000))

hist_top <- ggplot(df, aes(x = x)) + geom_density()

empty <-
  ggplot()+geom_point(aes(1,1), colour="white")+
  theme(axis.ticks=element_blank(), 
        panel.background=element_blank(), 
        axis.text.x=element_blank(), axis.text.y=element_blank(),
        axis.title.x=element_blank(), axis.title.y=element_blank())

scatter <- ggplot(df, aes(x = x, y = y)) + geom_point()

hist_right <- ggplot(df, aes(x = y)) + geom_density() + coord_flip()

grid.arrange(hist_top, empty, scatter, hist_right, ncol=2, nrow=2, widths=c(4, 2), heights=c(1, 4))
```

# knitr/kableExtra
kable is provided by `knitr` package. `kableExtra` enhance it with more functions. So we load both packages.

    `r chunk`{r shiny_block}
    library(knitr)
    library(kableExtra)
    
    # This is HTML output
    kable(df, format = "html")
    
    # Use function() { } to output html
    output$p1 <- function() {
      kable(df, format = "html")
    }
    `r chunk`

# kable_styling
- Get all styles from here
https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html

- style

    kable(dt, "html") %>%
      kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                    font_size = 12,
                    full_width = F, # True for left-to-right width
                    position = "left") # if full_width == F

- column_spec

    column_spec(1, bold = T, border_right = T) %>%
    column_spec(2, width = "30em", background = "yellow")

- row_spec

    column_spec(5:7, bold = T) %>%
    row_spec(3:5, bold = T, color = "white", background = "#D7261E")    

- cell_spec

    mtcars[1:10, 1:2] %>%
      mutate(
        car = row.names(.),
        # You don't need format = "html" if you have ever defined options(knitr.table.format)
        mpg = cell_spec(mpg, "html", color = ifelse(mpg > 20, "red", "blue")),
        cyl = cell_spec(cyl, "html", color = "white", align = "c", angle = 45, 
                        background = factor(cyl, c(4, 6, 8), 
                                            c("#666666", "#999999", "#BBBBBB")))
      ) %>%
      select(car, mpg, cyl) %>%
      kable("html", escape = F) %>%
      kable_styling("striped", full_width = F)

    volatility surface.

    Include all cells for colors, using gather, cell_spec, then spread

iris[1:10, ] %>%
  mutate_if(is.numeric, function(x) {
    cell_spec(x, "html", bold = T, color = spec_color(x, end = 0.9),
              font_size = spec_font_size(x))
  }) %>%
  mutate(Species = cell_spec(
    Species, "html", color = "white", bold = T,
    background = spec_color(1:10, end = 0.9, option = "A", direction = -1)
  )) %>%
  kable("html", escape = F, align = "c") %>%
  kable_styling("striped", full_width = F)

# Lecture 10: Model 

First, you define a family of models that express a precise, but generic, pattern that you want to capture. For example, the pattern might be a straight line, or a quadatric curve. You will express the model family as an equation like y = a_1 * x + a_2 or y = a_1 * x ^ a_2. Here, x and y are known variables from your data, and a_1 and a_2 are parameters that can vary to capture different patterns.

Next, you generate a fitted model by finding the model from the family that is the closest to your data. This takes the generic model family and makes it specific, like y = 3 * x + 7 or y = 9 * x ^ 2.

install.package("purrr", "modelr")
library(purrr)
library(modelr)

# Data set
sim1

model1 <- function(a, data) {
  a[1] + data$x * a[2]
}

measure_distance <- function(mod, data) {
  diff <- data$y - model1(mod, data)
  sqrt(mean(diff ^ 2))
}
best <- optim(c(0, 0), measure_distance, data = sim1)
best$par

sim1_mod <- lm(y ~ x, data = sim1)
coef(sim1_mod)

# prediction is for the new data
sim1 %>%
data_grid(x) %>% # generate data set.
add_predictions(sim1_mod) 

ggplot(sim1, aes(x)) +
  geom_point(aes(y = y)) +
  geom_line(aes(y = pred), data = grid, colour = "red", size = 1)

# residual is for the existing data
add_residuals(sim1_mod, sim1)

ggplot(sim1, aes(resid)) + 
  geom_freqpoly(binwidth = 0.5)

# apply it for the bank dataset
ggplot(bank) + geom_bar(aes(x = age, fill = y))

model_matrix(bank, y ~ age)

bank_mod <- lm(y ~ age, data = mutate(bank, y = ifelse(y == "yes", 1, 0)))

# add_prediction
mutate(bank, y = ifelse(y == "yes", 1, 0)) %>% data_grid(age) %>% add_predictions(bank_mod)
mutate(bank, y = ifelse(y == "yes", 1, 0)) %>% data_grid(age) %>% add_predictions(bank_mod) %>% ggplot(aes(x = age, y = pred)) + geom_point()

mutate(bank, y = ifelse(y == "yes", 1, 0)) %>% add_residuals(bank_mod) %>%
ggplot(aes(resid)) + 
  geom_freqpoly(binwidth = 0.05) 

# 2nd model
bank_mod <- lm(y ~ age * job, data = mutate(bank, y = ifelse(y == "yes", 1, 0)))
mutate(bank, y = ifelse(y == "yes", 1, 0)) %>% data_grid(age, job) %>%
  add_predictions(bank_mod) %>%
  ggplot(aes(x = age, colour = job)) + geom_line(aes(y = pred))

mutate(bank, y = ifelse(y == "yes", 1, 0)) %>% add_residuals(bank_mod) %>%
ggplot(aes(x = age, resid, colour = job)) +
  geom_point()

# model 
model_matrix(df, y ~ I(x^2) + x)

# try age with balance?

with different jobs

by_job <- group_by(bank, job) %>% nest()
job_balance <- function(df) {
  lm(balance ~ age, data = df)
}
models <- mutate(by_job, model = purrr::map(data, job_balance))

by_job_res <- models %>%
  mutate(resids = map2(data, model, add_residuals))

resids <- unnest(by_job_res, resids)

resids %>% 
  ggplot(aes(age, resid)) +
    geom_line(aes(colour = job)) + 
    geom_smooth(se = FALSE)

resids %>%
  ggplot(aes(age, resid, group = job)) +
    geom_line(alpha = 1 / 3) + 
    facet_wrap(~job)

# natural spine

mod1 <- lm(y ~ ns(x, 1), data = sim5)

mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)

# Regression Model
```{r, echo = T}
library(ggplot2)

set.seed(123)
N <- 1000
x <- rnorm(N)
f <- function(x) 50*x^2/(1 + 4*x) # data-simulating function

y <- f(x) + rnorm(N, sd=3)

point_data <- data.frame(x, y)

library("tidyverse")

ggplot(point_data, aes(x=x, y=y)) + 
  geom_point() + 
  ylim(-100, 100) + 
  ggtitle("simulated data points")

fit_pade <- function(point_data){
  fit <- lm(y ~ x + I(x^2) + I(y*x) + I(y*x^2), point_data)
  lm_coef <- as.list(coef(fit))
  names(lm_coef) <- c("a0", paste0(rep(c('a','b'), each=2), 1:2))
  
  with(lm_coef, function(x)(a0 + a1*x + a2*x^2)/(1 - b1*x - b2*x^2))
}

plot_fitted_function <- function(x_data, fitted_fun, title){
  x_data$y_hat <- fitted_fun(x_data$x)
  g <- ggplot(x_data, aes(x=x, y=y)) + 
    geom_point() + ylim(-100, 100) +
    geom_line(aes(y=y_hat), col="red", size=1) + 
    ggtitle(title)
  
  plot(g)
}

pade_approx <- fit_pade(point_data)

plot_fitted_function(point_data, pade_approx, title="fitted function")

function_list <- list(
  function(x) (100 - 50*x - 100*x^2)/(1 - 50*x - 5*x^2),
  function(x) (100 - 50*x - 100*x^2)/(1 - 10*x - 5*x^2),
  function(x) (100 - 50*x - 100*x^2)/(1 - 10*x - 10*x^2)
)

for (f in function_list){
  sim_data <- point_data %>% mutate(y=f(x) + 
                                      rnorm(nrow(point_data), sd=3))
  plot_fitted_function(sim_data, fit_pade(sim_data), 
                       title=as.character(deparse(f))[2])
}
```

# K-means
# K-means between two categorical variables
dev.off()
data.model <- select(bank, balance, education) %>% mutate(education = factor(education))
plot(data.model)
combination <- model.matrix(~ . - 1, data.model)
data.model$cl <- kmeans(combination, 4)$cluster
with(data.model, plot(balance, education, col = cl))

# K-means between one categorical variable + one numeric variable
dev.off()
data.model <- select(bank, job, education) %>% mutate(job = factor(job), education = factor(education))
plot(data.model)
combination <- model.matrix(~ . - 1, data.model)
data.model$cl <- kmeans(combination, 2)$cluster
with(data.model, plot(job, education, col = cl))

# K-means between two numeric variables
dev.off()
data.model <- select(bank, balance, duration)
plot(data.model)
data.model$cl <- kmeans(data.model[, 1:2], 4)$cluster
with(data.model, plot(balance, duration, col = cl))
with(data.model, text(balance, duration, col=cl))

# draw the 

library(xts)
xts object => store prices and retrieve.

library(fOption)

Option valuation.

How to value a portfolio of stocks?

How to value a portfolio of options?

How to simulate portfolio gain.

How to do SVD analysis?


# Object way and Data frame way
sample option portfolio
sample stock portfolio
