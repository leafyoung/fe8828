list = FALSE,
times = 1)
bank_train <- bank_new[ trainIndex,]
bank_test <- bank_new[-trainIndex,]
featurePlot(x = bank_new[-1],
y = bank_new$y,
plot = "density",
strip=strip.custom(par.strip.text=list(cex=.7)),
scales = list(x = list(relation="free"),
y = list(relation="free")))
eaturePlot(x = bank_new[-1],
y = bank_new$y,
plot = "density",
strip=strip.custom(par.strip.text=list(cex=.7)),
scales = list(x = list(relation="free"),
y = list(relation="free")))
train_control <- trainControl(
method = 'repeatedcv', # k-fold cross validation
number = 5, # number of folds
savePredictions = 'final', # saves predictions for optimal tuning parameter
classProbs = TRUE, # should class probabilities be returned
)
if (FALSE) {
# Running time is too long. Skip running.
adaboost_fit <- train(y ~ .,
data = bank_train,
method='adaboost',
tuneLength=2,
trControl = train_control)
adaboost_fit
predictions <- predict(adaboost_fit, newdata = bank_train)
confusionMatrix(predictions, bank_train$y)
predictions <- predict(adaboost_fit, bank_test)
confusionMatrix(predictions, bank_test$y)
}
featurePlot(x = bank_new[-1],
y = bank_new$y,
plot = "density",
strip=strip.custom(par.strip.text=list(cex=.7)),
scales = list(x = list(relation="free"),
y = list(relation="free")))
train_control <- trainControl(
method = 'repeatedcv', # k-fold cross validation
number = 5, # number of folds
savePredictions = 'final', # saves predictions for optimal tuning parameter
classProbs = TRUE, # should class probabilities be returned
)
if (FALSE) {
# Running time is too long. Skip running.
adaboost_fit <- train(y ~ .,
data = bank_train,
method='adaboost',
tuneLength=2,
trControl = train_control)
adaboost_fit
predictions <- predict(adaboost_fit, newdata = bank_train)
confusionMatrix(predictions, bank_train$y)
predictions <- predict(adaboost_fit, bank_test)
confusionMatrix(predictions, bank_test$y)
}
library(e1071)
# Logistic regression
log_fit <- train(y ~ .,
data = bank_train,
method = "glm",
family = binomial,
trControl = train_control)
predictions <- predict(log_fit, newdata = bank_train)
confusionMatrix(predictions, bank_train$y)
predictions <- predict(log_fit, bank_test)
confusionMatrix(predictions, bank_test$y)
# which(test$y != predictions)
summarise(bank_fit$y)
summary(bank_fit$y)
group_by(bank_fit,y) %>% summarise(nn=n())
bank_fit_y <- filter(bank_fit, y =="yes")
unique(bank_fit$y)
bank_fit_y
install.packages("rattle")
library(lubridate)
2004/4
2004%4
2004%%4
366/7
366//7
3665 %/% 7
365 %/% 7
365 %% 7
11 %/% 10
(26*14) %/% 10
1 in c(1,0)
1 %in% c(1,0)
library(lubridate)
count_bizday <- function(year) {
day1 <- 1
day2 <- 1
c <- (year-1) %/% 100
y <- (year-1) %% 100
w1 <- (1 + y + y%/%4 + c%/%4 +5*c+ 36) %% 7
w2 <- (w1+1) %% 7
if(w1 %in% c(1,0)){day1 <- 0}
if(w2 %in% c(1,0)){day2 <- 0}
if ((year%%4 != 0) | (year%%400 != 0 & year%%100 == 0)){
day2 <- 0
}
return(52*5+day1+day2)
}
count_bizday(2009)
count_bizday(2008)
count_bizday(20011)
count_bizday(2011)
count_bizday(2014)
count_bizday(2018)
count_bizday(2020)
df <- data_frame(
date = seq(as.Date("2019-01-01"), as.Date("2019-01-10"), by = "day"),
stock = replicate(10, paste0(sample(LETTERS, 3, replace = TRUE), collapse =
"")),
quantity = round(runif(10) * 10000 ,0))
df <- tibble(
date = seq(as.Date("2019-01-01"), as.Date("2019-01-10"), by = "day"),
stock = replicate(10, paste0(sample(LETTERS, 3, replace = TRUE), collapse =
"")),
quantity = round(runif(10) * 10000 ,0))
library(tibble)
df <- tibble(
date = seq(as.Date("2019-01-01"), as.Date("2019-01-10"), by = "day"),
stock = replicate(10, paste0(sample(LETTERS, 3, replace = TRUE), collapse =
"")),
quantity = round(runif(10) * 10000 ,0))
View(df)
LETTERS
df[c(3, 6, 9), , drop = F]
df[, 1, drop = FALSE]
df[, 1, drop = TRUE]
res1 <- purrr::map(1:10, function(x) { rnorm(x, n = 10) })
View(res1)
View(res1)
View(res1)
res1 <- purrr::map(1:10, function(x) { rnorm(x, n = 1000) })
a <- 1:10
a[1]
a[[1]]
a <- 10:1
a[1]
a <-c(a,s,d,g,,g,h,b,c,x)
a <-c('a','s','d','g','h','b','c','x')
a[1]
a[[1]]
make_choice <- function(N, split_number){
input_list <- sample(1:N, N, replace = FALSE)
best_evaluation <- input_list[[1]]
for (i in 2:split_number) {
if(best_evaluation < input_list[[i]]){best_evaluation <- input_list[[i]]}
}
for (i in (split_number+1):N) {
if(input_list[[i]] > best_evaluation){
best_selection <- input_list[[i]]
break
}
}
best_selection
}
make_choice(100,78)
make_choice <- function(N, split_number){
input_list <- sample(1:N, N, replace = FALSE)
best_selection <- 1
best_evaluation <- input_list[[1]]
for (i in 2:split_number) {
if(best_evaluation < input_list[[i]]){best_evaluation <- input_list[[i]]}
}
for (i in (split_number+1):N) {
if(input_list[[i]] > best_evaluation){
best_selection <- input_list[[i]]
break
}
}
best_selection
}
make_choice(100,78)
make_choice(100,50)
a[2:3]
a[[2:3]]
#Question 2: secretary question
library(purrr)
a[2:3]
b<-0
b++
0
b <- b+1
find_optimal <- function(N){
split_number <- 1:N%/%2
prob <- purrr::map(1:N%/%2, function(x){
count <- 0
for (i in 1:400) {
if(make_choice(x)==N){count <- count+1}
}
probabilty <- count/400
})
prob[match(map_dbl(prob,max),prob)]
}
find_optimal(3)
prob <- purrr::map(1:4%/%2, function(x){
count <- 0
for (i in 1:400) {
if(make_choice(x)==N){count <- count+1}
}
probabilty <- count/400
})
function(x){
count <- 0
for (i in 1:400) {
if(make_choice(x)==N){count <- count+1}
}
probabilty <- count/400}
function(3){
count <- 0
for (i in 1:400) {
if(make_choice(x)==N){count <- count+1}
}
probabilty <- count/400}
(function(x){
count <- 0
for (i in 1:400) {
if(make_choice(x)==N){count <- count+1}
}
probabilty <- count/400
})(3)
(function(x){
count <- 0
for (i in 1:400) {
if(make_choice(100,x)==100){count <- count+1}
}
probabilty <- count/400
})(3)
(function(x){
count <- 0
for (i in 1:400) {
if(make_choice(100,x)==100){count <- count+1}
}
probabilty <- count/400
probabilty
})(3)
(function(x){
count <- 0
for (i in 1:400) {
if(make_choice(100,x)==100){count <- count+1}
}
count/400
})(3)
prob <- purrr::map(1:100%/%2, function(x){
count <- 0
for (i in 1:400) {
if(make_choice(100,x)==100){count <- count+1}
}
count/400
})
make_choice <- function(N, split_number){
input_list <- sample(1:N, N, replace = FALSE)
best_selection <- 1
best_evaluation <- input_list[1]
for (i in 2:split_number) {
if(best_evaluation < input_list[i]){best_evaluation <- input_list[i]}
}
for (i in (split_number+1):N) {
if(input_list[i] > best_evaluation){
best_selection <- input_list[i]
break
}
}
best_selection
}
prob <- purrr::map(1:100%/%2, function(x){
count <- 0
for (i in 1:400) {
if(make_choice(100,x)==100){count <- count+1}
}
count/400
})
make_choice(100,50)
make_choice(100,30)
make_choice(100,2)
prob <- purrr::map(1:50, function(x){
count <- 0
for (i in 1:400) {
if(make_choice(100,x)==100){count <- count+1}
}
count/400
})
prob <- purrr::map(1:100 %/% 2, function(x){
count <- 0
for (i in 1:400) {
if(make_choice(100,x)==100){count <- count+1}
}
count/400
})
prob <- purrr::map(1:100 / 2, function(x){
count <- 0
for (i in 1:400) {
if(make_choice(100,x)==100){count <- count+1}
}
count/400
})
prob <- purrr::map(1:(100%/%2), function(x){
count <- 0
for (i in 1:400) {
if(make_choice(100,x)==100){count <- count+1}
}
count/400
})
find_optimal <- function(N){
split_number <- 1:N%/%2
prob <- purrr::map(1:(N%/%2), function(x){
count <- 0
for (i in 1:400) {
if(make_choice(N,x)==N){count <- count+1}
}
count/400
})
split_number[match(map_dbl(prob,max),prob)]
}
split_number[match(map_dbl(prob,max),prob)
]
split_number <- 1:N%/%2
split_number <- 1:(100%/%2)
split_number[match(map_dbl(prob,max),prob)]
View(prob)
max(prob)
View(prob)
prob.max
max(a)
x <- purrr::map2_dbl(prob,prob)
prob <- as.vector(prob)
prob <- as.vector(unlist(prob))
split_number[match(max(prob),prob)]
find_optimal <- function(N){
split_number <- 1:(N%/%2)
prob <- purrr::map(1:(N%/%2), function(x){
count <- 0
for (i in 1:400) {
if(make_choice(N,x)==N){count <- count+1}
}
count/400
})
prob <- as.vector(unlist(prob))
split_number[match(max(prob),prob)]
}
find_optimal(3)
find_optimal(10)
find_optimal(100)
shiny::runApp('Desktop/NTU/PROGRAMMING WEB APPLICATIONS IN FINANCE/FE8828-Qu Mengyuan/Assignment2/A2_Q4')
shiny::runApp()
#Question 3: Birth ratio question
library(tidyverse)
ratio <- sample(1:10,1000, replace = TRUE)
plot(density(ratio))
sample(c(0,1), 100, replace = TRUE) # 0 represents Female, 1 represents Male
trial <- purrr::map(1:10,function(){
sample(c(0,1), 100, replace = TRUE) # 0 represents Female, 1 represents Male
})
trial <- purrr::map(1:10,function(x){
sample(c(0,1), 100, replace = TRUE) # 0 represents Female, 1 represents Male
})
View(trial)
a
a <- c
a[1] <- 1
View(a)
rm(a)
a[1] <- 1
rm(a)
a[[1] <- 1
a[1] <- c(1)
rm(a)
ratio <- rep(0,1000)
which(trial==1)
trial[[1]]
trial[[1]][2]
which(trial[[1]]==1)
which(trial[[1]]==1)[1]
library(tidyverse)
ratio <- rep(0,1000)
for (i in 1000) {
girl = 0
trial <- purrr::map(1:10,function(x){
sample(c(0,1), 100, replace = TRUE) # 0 represents Female, 1 represents Male
})
for (j in 1:10) {
girl = girl + which(trial[[j]]==1)[1]-1
}
ratio[i] <- girl/10
}
plot(density(ratio))
view(ratio)
a <- rep(0,10)
a[1] <- 2
View(trial)
for (j in 1:10) {
girl = girl + which(trial[[j]]==1)[1]-1
}
ratio[1] <- (girl/10)
for (i in 1000) {
girl = 0
trial <- purrr::map(1:10,function(x){
sample(c(0,1), 100, replace = TRUE) # 0 represents Female, 1 represents Male
})
for (j in 1:10) {
girl = girl + which(trial[[j]]==1)[1]-1
}
ratio[i] <- (girl/10)
}
for (i in 1:1000) {
girl <- 0
trial <- purrr::map(1:10,function(x){
sample(c(0,1), 100, replace = TRUE) # 0 represents Female, 1 represents Male
})
for (j in 1:10) {
girl = girl + which(trial[[j]]==1)[1]-1
}
ratio[i] <- (girl/10)
}
plot(density(ratio))
library(tidyverse)
ratio <- rep(0,1000)
for (i in 1:1000) {
girl <- 0
trial <- purrr::map(1:10,function(x){
sample(c(0,1), 100, replace = TRUE) # 0 represents Female, 1 represents Male
})
for (j in 1:10) {
girl = girl + which(trial[[j]]==1)[1]-1
}
ratio[i] <- (girl/(girl+10))
}
plot(density(ratio))
plot(density(ratio))+
title("percentage of girls")
plot(density(ratio),title = "percentage of girls")
plot(density(ratio,title = "percentage of girls"))
plot(density(ratio))
xlab("percentage of girls)
plot(density(ratio))+
xlab("percentage of girls")
plot(density(ratio))+xlab("percentage of girls")
plot(density(ratio))+xlab(x="percentage of girls")
plot(density(ratio))+labs(title ="percentage of girls")
plot(density(ratio))+labs(title ="percentage")
library(tidyverse)
ratio <- rep(0,1000)
for (i in 1:1000) {
girl <- 0
trial <- purrr::map(1:10,function(x){
sample(c(0,1), 100, replace = TRUE) # 0 represents Female, 1 represents Male
})
for (j in 1:10) {
girl = girl + which(trial[[j]]==1)[1]-1
}
ratio[i] <- (girl/(girl+10))
}
plot(density(ratio))
library(tidyverse)
ratio <- rep(0,1000)
for (i in 1:1000) {
girl <- 0
trial <- purrr::map(1:10,function(x){
sample(c(0,1), 100, replace = TRUE) # 0 represents Female, 1 represents Male
})
for (j in 1:10) {
girl = girl + which(trial[[j]]==1)[1]-1
}
ratio[i] <- (girl/(girl+10))
}
plot(density(ratio))
library(tidyverse)
ratio <- rep(0,1000)
for (i in 1:1000) {
girl <- 0
trial <- purrr::map(1:10,function(x){
sample(c(0,1), 100, replace = TRUE) # 0 represents Female, 1 represents Male
})
for (j in 1:10) {
girl = girl + which(trial[[j]]==1)[1]-1
}
ratio[i] <- (girl/(girl+10))
}
plot(density(ratio))
library(tidyverse)
ratio <- rep(0,1000)
for (i in 1:1000) {
girl <- 0
trial <- purrr::map(1:10,function(x){
sample(c(0,1), 100, replace = TRUE) # 0 represents Female, 1 represents Male
})
for (j in 1:10) {
girl = girl + which(trial[[j]]==1)[1]-1
}
ratio[i] <- (girl/(girl+10))
}
plot(density(ratio))
library(tidyverse)
ratio <- rep(0,1000)
for (i in 1:1000) {
girl <- 0
trial <- purrr::map(1:10,function(x){
sample(c(0,1), 100, replace = TRUE) # 0 represents Female, 1 represents Male
})
for (j in 1:10) {
girl = girl + which(trial[[j]]==1)[1]-1
}
ratio[i] <- (girl/(girl+10))
}
plot(density(ratio))
