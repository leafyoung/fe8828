---
title: "Assignment 2 - Choice Problem"
author: "Cai Qi (G1800346L)"
date: "2018/11/18"
output: html_document
---

### Problem Statement
The choice problem is about a scenario involving optimal stopping theory.

The basic form of the problem is the following: 

* imagine a princess who wants to marry the best man out of N rankable applicants. The applicants are interviewed one by one in random order.

* A decision about each particular applicant has to be made **immediately after the interview.** Once rejected, an applicant **cannot be recalled.**

* During the interview, the administrator can rank the applicant among all applicants interviewed so far, but is unaware of the quality of yet unseen applicants. 

The question is about the optimal strategy to maximize the probability of selecting the best applicant.

### Problem Solving
With the help of computer programming, we can solve this problem by the exhaustive method.

We can split the N applicants into two groups, observation group and test group. The strategy is that we reject all the applicants in the observation group, and then accept **the first applicant in test group who is better than the best applicant in observation group.** What we need to do is to exhaust all the possible number of applicants in observation group, which is obviously from 1 to N-1. After calculating all the probabilities of selecting the true best applicant, we can conclude that how large the observation group should be in order to maximize the probability. 

#### Step 1
Assume there are total `N` applicants and the number of applicants in obervation group is `split_number`. We first allocate distinct score to every applicants, which make them rankable. Then, we make a choice of the best applicant corresponding to every specific observation group. 

We first record the best applicant in observation group. And then compare it to the applicants in test group one by one. If applicant A is better than the record one, we choose applicant A and stop the interview. If no one in test group is better than the recourd one, we will choose the last applicant in test group.

Codes below will return our choice for a specific `split_number` and a specific senario of all the applicants.
```R
make_choice<-function(N,split_number){
  input_list<-sample(1:N,N,replace = FALSE)
  best_n<-max(input_list[1:split_number])
  if(best_n==N) 
    return(input_list[N])
  else{
    for (i in (split_number+1):N) {
      if(best_n<input_list[i]){
        return(input_list[i])
        break
  }}}}
```

#### Step 2
To find the optimal `split_number`, we exhaut all the possible number of applicants in observation group, which is obviously from 1 to N-1. For each `split_number`, we take step 1 many times and calculate the probability of choosing the real best applicant among all.

After comparing the probabilities related to different `split_number`, we can get the `split_number` that correspond to the highest probability.

Also, we calculate the average score of our choices with different `split_number`.

```R
find_optimal<-function(N,run_time){
  choice_mean<-c()
  prob_opt<-c()
    for (split_numer in 1:(N-1)) {
      count_opt<-0
      choice_res<-c()
      for (i in 1:run_time) 
        choice_res[i]<-make_choice(N,split_numer)
      count_opt<-sum(ifelse(choice_res==N,1,0))
      prob_opt[split_numer]<-count_opt/run_time
      choice_mean[split_numer]<-mean(choice_res)
    }
  best_split<-0
  best_mean<-0
    for (i in 1:(N-1)) {
      if(prob_opt[i]==max(prob_opt))
        best_split<-i
      if(choice_mean[i]==max(choice_mean))
        best_mean<-i
    }
#plot(choice_mean)
#plot(prob_opt)
return(best_split)
}
```
#### Step 3
Because the limit times we run for step 1, the result we gain in step 2 varies, especially when N is large. In this situation, we can run step 2 for some times and get a plot to observ the variation of the optimal value for the split for N.

```R
N<-100           ## total number of applicants
run_time<-1000   ## run step 1 for 1000 times.
best_split_num<-c()
  for (i in 1:10)
    best_split_num[i]<-find_optimal(N,run_time)
  plot(best_split_num)
```



### Result Discussion

#### Case: N=3
We first run step 1 for 1000 times to gain the estimated optimal value for the split for 3 applicants. This 3 applicants are scored by 1,2,3.
```{r n3, echo=FALSE}
make_choice<-function(N,split_number){
  input_list<-sample(1:N,N,replace = FALSE)
  best_n<-max(input_list[1:split_number])
  if(best_n==N) return(input_list[N])
  else{
  for (i in (split_number+1):N) {
    if(best_n<input_list[i]){
      return(input_list[i])
      break
}}}}

N<-3
run_time<-1000
choice_mean<-c()
prob_opt<-c()
for (split_numer in 1:(N-1)) {
  count_opt<-0
  choice_res<-c()
  for (i in 1:run_time) 
    choice_res[i]<-make_choice(N,split_numer)
  count_opt<-sum(ifelse(choice_res==N,1,0))
  choice_mean[split_numer]<-mean(choice_res)
  prob_opt[split_numer]<-count_opt/run_time
}

best_split<-0
best_mean<-0
for (i in 1:(N-1)) {
  if(prob_opt[i]==max(prob_opt))
    best_split<-i
  if(choice_mean[i]==max(choice_mean))
    best_mean<-i
}
plot(prob_opt)
cat("The optimal value for split is",best_split,", which has probability of",max(prob_opt),"to gain the true best applicant.")
plot(choice_mean)
cat("When the observation group has",best_mean,"applicants, we gain",max(choice_mean),"as the maximum of average score of our selected applicant.")
```

If we repeat this process for many times, we can observ whether our result above is convincing.

```{r echo=FALSE}
make_choice<-function(N,split_number){
  input_list<-sample(1:N,N,replace = FALSE)
  best_n<-max(input_list[1:split_number])
  if(best_n==N) return(input_list[N])
  else{
  for (i in (split_number+1):N) {
    if(best_n<input_list[i]){
      return(input_list[i])
      break
  }}}}

find_optimal<-function(N,run_time){

choice_mean<-c()
prob_opt<-c()
for (split_numer in 1:(N-1)) {
  count_opt<-0
  choice_res<-c()
  for (i in 1:run_time) 
    choice_res[i]<-make_choice(N,split_numer)
  count_opt<-sum(ifelse(choice_res==N,1,0))
  choice_mean[split_numer]<-mean(choice_res)
  prob_opt[split_numer]<-count_opt/run_time
}
best_split<-0
best_mean<-0
for (i in 1:(N-1)) {
  if(prob_opt[i]==max(prob_opt))
    best_split<-i
  if(choice_mean[i]==max(choice_mean))
    best_mean<-i
}
return(best_split)
}

best_split_num<-c()
for (i in 1:10) {
  best_split_num[i]<-find_optimal(3,1000)
}
plot(best_split_num)
cat("The average of optimal value of split for 3 applicants is",mean(best_split_num),".")
```


#### Case: N=10
We first run step 1 for 1000 times to gain the estimated optimal value for the split for 10 applicants. This 10 applicants are scored from 1 to 10.
```{r n10, echo=FALSE}
make_choice<-function(N,split_number){
  input_list<-sample(1:N,N,replace = FALSE)
  best_n<-max(input_list[1:split_number])
  if(best_n==N) return(input_list[N])
  else{
  for (i in (split_number+1):N) {
    if(best_n<input_list[i]){
      return(input_list[i])
      break
}}}}

N<-10
run_time<-1000
choice_mean<-c()
prob_opt<-c()
for (split_numer in 1:(N-1)) {
  count_opt<-0
  choice_res<-c()
  for (i in 1:run_time) 
    choice_res[i]<-make_choice(N,split_numer)
  count_opt<-sum(ifelse(choice_res==N,1,0))
  choice_mean[split_numer]<-mean(choice_res)
  prob_opt[split_numer]<-count_opt/run_time
}

best_split<-0
best_mean<-0
for (i in 1:(N-1)) {
  if(prob_opt[i]==max(prob_opt))
    best_split<-i
  if(choice_mean[i]==max(choice_mean))
    best_mean<-i
}
plot(prob_opt)
cat("The optimal value for split is",best_split,", which has probability of",max(prob_opt),"to gain the true best applicant.")
plot(choice_mean)
cat("When the observation group has",best_mean,"applicants, we gain",max(choice_mean),"as the maximum of average score of our selected applicant.")
```

If we repeat this process for many times, we can observ whether our result above is convincing.

```{r echo=FALSE}
make_choice<-function(N,split_number){
  input_list<-sample(1:N,N,replace = FALSE)
  best_n<-max(input_list[1:split_number])
  if(best_n==N) return(input_list[N])
  else{
  for (i in (split_number+1):N) {
    if(best_n<input_list[i]){
      return(input_list[i])
      break
  }}}}

find_optimal<-function(N,run_time){

choice_mean<-c()
prob_opt<-c()
for (split_numer in 1:(N-1)) {
  count_opt<-0
  choice_res<-c()
  for (i in 1:run_time) 
    choice_res[i]<-make_choice(N,split_numer)
  count_opt<-sum(ifelse(choice_res==N,1,0))
  choice_mean[split_numer]<-mean(choice_res)
  prob_opt[split_numer]<-count_opt/run_time
}
best_split<-0
best_mean<-0
for (i in 1:(N-1)) {
  if(prob_opt[i]==max(prob_opt))
    best_split<-i
  if(choice_mean[i]==max(choice_mean))
    best_mean<-i
}
return(best_split)
}

best_split_num<-c()
for (i in 1:10) {
  best_split_num[i]<-find_optimal(10,1000)
}
plot(best_split_num)
cat("The average of optimal value of split for 10 applicants is",mean(best_split_num),".")
```

#### Case: N=100
We first run step 1 for 1000 times to gain the estimated optimal value for the split for 100 applicants. This 100 applicants are scored from 1 to 100.
```{r n100, echo=FALSE}
make_choice<-function(N,split_number){
  input_list<-sample(1:N,N,replace = FALSE)
  best_n<-max(input_list[1:split_number])
  if(best_n==N) return(input_list[N])
  else{
  for (i in (split_number+1):N) {
    if(best_n<input_list[i]){
      return(input_list[i])
      break
}}}}

N<-100
run_time<-1000
choice_mean<-c()
prob_opt<-c()
for (split_numer in 1:(N-1)) {
  count_opt<-0
  choice_res<-c()
  for (i in 1:run_time) 
    choice_res[i]<-make_choice(N,split_numer)
  count_opt<-sum(ifelse(choice_res==N,1,0))
  choice_mean[split_numer]<-mean(choice_res)
  prob_opt[split_numer]<-count_opt/run_time
}

best_split<-0
best_mean<-0
for (i in 1:(N-1)) {
  if(prob_opt[i]==max(prob_opt))
    best_split<-i
  if(choice_mean[i]==max(choice_mean))
    best_mean<-i
}
plot(prob_opt)
cat("The optimal value for split is",best_split,", which has probability of",max(prob_opt),"to gain the true best applicant.")
plot(choice_mean)
cat("When the observation group has",best_mean,"applicants, we gain",max(choice_mean),"as the maximum of average score of our selected applicant.")
```

If we repeat this process for many times, we can observ whether our result above is convincing.

```{r echo=FALSE}
make_choice<-function(N,split_number){
  input_list<-sample(1:N,N,replace = FALSE)
  best_n<-max(input_list[1:split_number])
  if(best_n==N) return(input_list[N])
  else{
  for (i in (split_number+1):N) {
    if(best_n<input_list[i]){
      return(input_list[i])
      break
  }}}}

find_optimal<-function(N,run_time){

choice_mean<-c()
prob_opt<-c()
for (split_numer in 1:(N-1)) {
  count_opt<-0
  choice_res<-c()
  for (i in 1:run_time) 
    choice_res[i]<-make_choice(N,split_numer)
  count_opt<-sum(ifelse(choice_res==N,1,0))
  choice_mean[split_numer]<-mean(choice_res)
  prob_opt[split_numer]<-count_opt/run_time
}
best_split<-0
best_mean<-0
for (i in 1:(N-1)) {
  if(prob_opt[i]==max(prob_opt))
    best_split<-i
  if(choice_mean[i]==max(choice_mean))
    best_mean<-i
}
return(best_split)
}

best_split_num<-c()
for (i in 1:10) {
  best_split_num[i]<-find_optimal(100,1000)
}
plot(best_split_num)
cat("The average of optimal value of split for 100 applicants is",mean(best_split_num),".")
```


### Conclusion
In conclusion, we gain the estimated optimal value of split for different number of applicants, which is consistent with the odds algorithm that the theoretically optimal value of split for $n$ applicants is $n\over e$.

* For N=3, the optimal value of split is 1. For N=10, the optimal value is between 3 to 4. For N=100,optimal value of split is around 37.

* If we want to obtain the maximum expected score of the applicants instead of the best score, the optimal value of split is smaller. For example, for N=10, we can maximize the expected score of our selected applicant by including 2 applicants in observation group.



