---
title: "FE8828 Programming Web Applications in Finance - Final Assignment"
author: "Group A - Ng Lay Yong, Wu Siying, Dong Jiaqi, Tao Ye, Fang You"
date: "09/12/2018"
output: html_document
---
## Setting up R and installing FX rates
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(randomNames)
library(dplyr)
library(tidyverse)
library(sqldf)
library(htmlTable)
library(kableExtra)
library(xtable)
library(tidyr)
library(tidyquant)
library(fOptions)
library(DT)
```

## 1. Bank

```{r FX_Rates, echo =FALSE}
#The exchange rates were downloaded from the https://secure.mas.gov.sg/msb/ExchangeRates.aspx
#Also, for the exchange rates on weekends, assuming it is same as the rate on Friday.
rates <- read.csv("FX.csv",header=TRUE, sep=",")
#Currency to SGD
rates <- as.data.frame(rates) 
rates$Date <- as.Date(rates$Date)
```

#### Design Description
1. Generate the first dataframe, containing clients' AccountNo, Name, Initial Deposit and Initial Credit
```{r datafram1, echo=FALSE}
Name <- randomNames(10)
set.seed(10)
Deposit <- sample(5000:10000,10,replace =TRUE)
Credit <- sample(5000:10000,10, replace=TRUE)
set.seed(10)
AccountNo <- vector()
for(i in 1:10)
  AccountNo[i] <- paste( sample( 0:9, 5, replace=TRUE ), collapse="" )
  # accoutn[i] <- paste(c(sample(1:9,1), sample( 0:9, 19, replace=TRUE )), collapse="")
#Data Frame 1: Account
# Deposit <- sample(5000:10000,10,replace=TRUE)
# Credit <- sample(5000:10000,10,replace = TRUE)
df <- data.frame(AccountNo,Name,Deposit,Credit,Total=Deposit+Credit)
df
# df$Total <- df$Deposit + df$Credit
```

2. Generate 200 transactions with no restrictions as the as transaction for A client first and then use the dplyr to filter the transactons
```{r dataframe2, echo = FALSE}
Total_T=200; #Total number of Transactions within 3 month #No restriction
TransactionNo <- sort(sample(1:200,200,replace=FALSE))
TType <- c("Withdraw", "Deposit", "Spend")
TransactionType <- sample(TType,200,replace = TRUE)
# TAccount <- sample(AccountNo[1], 1, replace = TRUE) #For the first Account 
CR <- c("CNY","USD","SGD")
Date <- sort(sample(seq(as.Date('2018/07/01'), as.Date('2018/09/30'), by="day"),200, replace = TRUE))
Currency <- sample(CR,200, replace = TRUE)
Amount <- sample(1:5000, 200, replace = TRUE)
df2 <- data.frame(TransactionNo, Date, TransactionType,Amount, Currency) 
df2 <- within(df2, Amount[TransactionType!="Deposit"] <-(Amount[TransactionType!="Deposit"]*(-1)))

```

3. The transaction history for a client before data massaging then to make the data to satisfying the conditions. The following is the data before processing.
```{r deposit,echo = FALSE}
df2 %>%
  dplyr::filter(Date > "2018-07-01" & Date <"2018-07-31") %>%
  dplyr::filter(TransactionType =="Deposit") %>%
  dplyr::filter(Amount >= 3000 & Amount <=5000) %>%
  sample_n(sample(c(1,2),1)) -> df3

df2 %>%
  dplyr::filter(Date > "2018-08-01" & Date <"2018-08-31") %>%
  dplyr::filter(TransactionType =="Deposit") %>%
  dplyr::filter(Amount >= 3000 & Amount <=5000) %>%
  sample_n(sample(c(1,2),1)) -> df4


df2 %>% 
  dplyr::filter(Date > "2018-09-01" & Date <"2018-09-30") %>%
  dplyr::filter(TransactionType =="Deposit") %>%
  dplyr::filter(Amount >= 3000 & Amount <=5000) %>%
  sample_n(sample(c(1,2),1)) -> df5
```


```{r Withdraw&Spend,echo = FALSE}

df2 %>% 
  dplyr::filter(TransactionType =="Spend") %>%
  sample_n(sample(c(0:60),1)) -> df6

df2 %>% 
  dplyr::filter(TransactionType =="Withdraw") %>%
  sample_n(sample(c(0:60),1)) -> df7


temp <- as.data.frame(rbind(df3,df4,df5,df6,df7))
temp1 <- temp[order(temp$TransactionNo),]

temp1$TAccount <- df$AccountNo[1]
temp1$Deposit <- df$Deposit[1]
temp1$Credit <- df$Credit[1]
temp1$Total <- temp1$Deposit+temp1$Credit
temp1
```

<!-- Generate random transaction data for 10 accounts during 2018-07-01 and 2018-09-30. Make it more -->
<!-- realistic, deposit is 1-2 times per month, a random number of 3000-5000, any of three currencies. -->
<!-- Spend/Withdraw can be any times [0, 60] and any amount, any currencies. Deposit is positive, -->
<!-- Withdraw/Spend is negative. Constraint: You cannot withdraw more than the deposit, cannot spend more -->
<!-- than credit + deposit. -->

4. We processed the transaction data for a client at first and then apply the same logic for the other nine clients.

5. We generate the transactions for 10 clients and each of the clients' transaction history is stored in a dataframe and then combined the all dataframes in a list.

The following code is the most important code, so it is shown below.
```{r th, echo=TRUE}
# temp1$Deposit <- df$Deposit[1]
# temp1$Credit <- df$Credit[1]
# temp1$Total <- df$Total[1]

myList <- list()

for (j in 1:10){

  df2 %>% 
    dplyr::filter(Date > "2018-07-01" & Date <"2018-07-31") %>%
    dplyr::filter(TransactionType =="Deposit") %>%
    dplyr::filter(Amount >= 3000 & Amount <=5000) %>%
    sample_n(sample(c(1,2),1),replace = TRUE) -> df3
  
  df2 %>%
    dplyr::filter(Date > "2018-08-01" & Date <"2018-08-31") %>%
    dplyr::filter(TransactionType =="Deposit") %>%
    dplyr::filter(Amount >= 3000 & Amount <=5000) %>%
    sample_n(sample(c(1,2),1),replace = TRUE) -> df4
  
  
  df2 %>% 
    dplyr::filter(Date > "2018-09-01" & Date <"2018-09-30") %>%
    dplyr::filter(TransactionType =="Deposit") %>%
    dplyr::filter(Amount >= 3000 & Amount <=5000) %>%
    sample_n(sample(c(1,2),1),replace = TRUE) -> df5
  
  
  df2 %>% 
    dplyr::filter(TransactionType =="Spend") %>%
    sample_n(sample(c(0:60),1),replace = TRUE) -> df6
  
  df2 %>% 
    dplyr::filter(TransactionType =="Withdraw") %>%
    sample_n(sample(c(0:60),1),replace = TRUE) -> df7
  
  temp <- as.data.frame(rbind(df3,df4,df5,df6,df7))
  temp1 <- temp[order(temp$TransactionNo),]
  
  
  
  temp1$TAccount <- df$AccountNo[j]
  temp1$Name <- df$Name[j]
  temp1$Deposit <- df$Deposit[j]
  temp1$Credit <- df$Credit[j]
  temp1$Total <- temp1$Deposit+temp1$Credit
  x <- as.data.frame(temp1)
  x <- rbind(data.frame(TransactionNo = 0, Date=temp1$Date[1], TAccount=temp1$TAccount[j], 
                        TransactionType ="Initial", 
                        Amount =0,
                        Name = "Test",
                        Currency = "test", Deposit = df$Deposit[j], Credit = df$Credit[j], 
                        Total = df$Deposit[j]+df$Credit[j]),x)
    
  
  x <-merge(x, rates, by="Date")
  x$Amount1 <- rep(0,nrow(x))
  x <- as.data.frame(x)
  
  #We do the above process recursively because we want to make sure that the each person's transaction history is not the same.
  
  

  #Amount is the amount in domestic currency(SGD) 
  #Amount is the amount in foreign currency (USD&CNY)
  
  for(i in 2:nrow(x)){
    x$Amount1[i] <- x$Amount[i]  
    if(x$Currency[i] =="USD")
      x$Amount[i] = x$USD[i]*x$Amount[i]
    if(x$Currency[i] =="CNY")
      x$Amount[i] = x$CNY[i]*x$Amount[i]
      
    # Amount should be less than deposit if its "Withdraw"
    if(x$TransactionType[i] == 'Withdraw' & x$Deposit[i-1]<abs(x$Amount[i]))
    {
      x$Amount[i] <- sample(1:(x$Deposit[i-1]/10), 1, replace = TRUE)*(-1) #To avoid bankruptcy
      x$Deposit[i] <- x$Deposit[i-1] + x$Amount[i]
      x$Credit[i] <- x$Credit[i-1]
    }
    # Cannot withdraw but could spend between 1 and credit[i-1]
    if(x$TransactionType[i] == 'Withdraw' & x$Deposit[i-1] ==0 ){
      x$TransactionType[i] <- 'Spend'
      x$Amount[i] <- sample(1:(x$Credit[i-1]/10), 1, replace = TRUE)*(-1) #To avoid bankruptcy
    }
    else if(x$TransactionType[i] == 'Withdraw' & x$Deposit[i-1] >= abs(x$Amount[i])){
      x$Deposit[i] <- x$Deposit[i-1] + x$Amount[i]
      x$Credit[i] <- x$Credit[i-1]
    }
    
    # Amount should be less than credit + deposit if it is "Spend"
    
    # if type = spend and the deposit accound is zero, should deduct the credit account 
    
    if((x$TransactionType[i] == 'Spend') & (abs(x$Amount[i])> x$Deposit[i-1]) & (abs(x$Amount[i]) <= x$Total[i-1])){
      x$Deposit[i] = 0
      x$Credit[i] = x$Credit[i-1]+x$Amount[i]-x$Deposit[i-1]
    }
    
    if(x$TransactionType[i] == 'Spend' & abs(x$Amount[i])> x$Total[i-1]){
      x$Amount[i] <- sample(1:(x$Total[i-1]/10), 1, replace = TRUE)*(-1)
      x$Deposit[i] <- max(x$Deposit[i-1]+x$Amount[i],0)
      if(x$Deposit[i]==0){
        x$Credit[i] <- x$Credit[i-1]+x$Amount[i]-x$Deposit[i-1]
      }
      else{
      x$Credit[i] <- x$Credit[i-1]
      }
    }
    else if(x$TransactionType[i] == 'Spend' & x$Deposit[i-1] >= abs(x$Amount[i])){
        x$Deposit[i] <- x$Deposit[i-1] + x$Amount[i]
        x$Credit[i] <- x$Credit[i-1]
    }
    
    if(x$TransactionType[i] == 'Deposit'){
      # x$Deposit[i+1] <- x$Amount[i] +  x$Deposit[i]
      x$Credit[i] <- x$Credit[i-1]
      x$Deposit[i] <- x$Amount[i] +  x$Deposit[i-1]
    }
    x$Total[i] <- x$Deposit[i] + x$Credit[i]
  }
    myList[[j]] <- x
}

cat("Transcation History for the first client")
kable(myList[[1]]) %>%
  kable_styling(bootstrap_options = c("striped","hover"))
cat("Transcation History for the second client")
kable(myList[[2]]) %>%
  kable_styling(bootstrap_options = c("striped","hover"))
```

#### Example
```{r Transaction Report, echo=FALSE}
#Take the first client for example
ex <- myList[[1]]

#Transaction History
ex %>% 
  dplyr::filter(Currency != "test")%>%
  dplyr::filter(Date >= "2018-07-01" & Date <="2018-07-31") %>%
  select(Date,TransactionType,Amount,Currency,Deposit,Credit) %>%
  rename("Deposit Balance" = Deposit, "Credit Balance" = Credit) -> exj

ex %>% 
  dplyr::filter(Currency != "test")%>%
  dplyr::filter(Date >= "2018-08-01" & Date <="2018-08-31") %>%
  select(Date,TransactionType,Amount,Currency,Deposit,Credit) %>%
  rename("Deposit Balance" = Deposit, "Credit Balance" = Credit) -> exa


ex %>% 
  dplyr::filter(Currency != "test")%>%
  dplyr::filter(Date >= "2018-09-01" & Date <="2018-09-30") %>%
  select(Date,TransactionType,Amount,Currency,Deposit,Credit) %>%
  rename("Deposit Balance" = Deposit, "Credit Balance" = Credit) -> exs

cat("Clien Name: ", as.character(ex$Name[[2]]))
cat("JULY")
kable(exj) %>%
  kable_styling(bootstrap_options = c("striped","hover"))
cat("AUGUST")
kable(exa) %>%
  kable_styling(bootstrap_options = c("striped","hover"))
cat("SEPTEMBER")
kable(exs) %>%
  kable_styling(bootstrap_options = c("striped","hover"))


#Transaction Summary

ex %>% 
  dplyr::filter(Currency != "test")%>%
  dplyr::filter(Date > "2018-07-01" & Date <"2018-07-31") %>%
  group_by(TransactionType) %>%
  summarize(Amount = sum(Amount)) -> exd

cat("Summary")
kable(exd) %>%
  kable_styling(bootstrap_options = c("striped","hover"))


```

## 2. Option trading - Dynamic Hedging

####Simulation below to prove first point:
[1] If realized volatility and implied volatility are the same, Gamma and Theta can neutralize each other

```{r}
runs<-10
length<-length(90:110)
res<-vector(mode="numeric",length=runs)
finalres<-vector(mode="numeric",length=21)
ImpliedVol<-vector(mode="numeric",length=22)
simulation1<-function(S,X){
  days <- 23 #for 22 working days ATM in 30 days, last row(23rd row) to be removed after creating lag vectors
  
  #for the ATM call option, K = S = 100, r = q = 0, vol = 0.3 constant till option expiry
  
  sigma <- 0.3 # realized vol can be 0.3 for [1] or 0.5 for [2]
  drift <- 0 # drift = r - q
  N <- days
  timestep <- 1 / 250
  p1 <- (drift - 0.5 * sigma * sigma) * timestep
  p2 <- sigma * sqrt(timestep)
  
  # ss is the simulated price movement for N days
  ss <- rep(S, N) * cumprod(rlnorm(N, mean = p1, sd = p2))
  
  # create a lag vector to calculate change in stock price, dS
  ss_lag <- dplyr::lag(ss, n=1L)
  ss_lag[1] <- S
  dS <- ss-ss_lag
  
  # simulated price of underlying and the respective greeks in each time period
  df <- data_frame(S = ss,dS = dS, days = 1:days)
  opt <- mutate(df,
                price = GBSOption("c", S = S, X = X, Time = (N-days)/ 250, r = 0, b = 0, sigma = 0.3)@price,
                delta = GBSGreeks("Delta", "c", S = S, X = X, Time = (N-days)/ 250, r = 0, b = 0, sigma = 0.3),
                gamma = GBSGreeks("Gamma", "c", S = S, X = X, Time = (N-days)/ 250, r = 0, b = 0, sigma = 0.3),
                theta = GBSGreeks("Theta", "c", S = S, X = X, Time = (N-days)/ 250, r = 0, b = 0, sigma = 0.3)
                
  )
  
  #create lag vector for option price
  price_lag <- dplyr::lag(opt$price, n=1L)
  price_lag[1] <- GBSOption("c", S = S, X = X, Time = 22/250, r = 0, b = 0, sigma = 0.3)@price
  
  #insert column for change in option price i.e. PnL
  opt <- mutate(opt,
                price_change = price-price_lag
  )
  
  #prove that gamma terms and theta terms neutralize each other
  opt <- mutate(opt,
                delta_term = delta*dS,
                gamma_term = 0.5*gamma*(dS)^2,
                theta_term = theta*timestep,
                dV = delta_term + gamma_term + theta_term,
                dV_remainder = dV - price_change,
                gamma_and_theta_terms = gamma_term + theta_term
                
  )
  #remove last row of NaN values
  finalopt<-opt[-nrow(opt),]
  
  for(i in 1:22){
    ImpliedVol[i]<<- GBSVolatility(opt$price[i],"c",S=opt$S[i],X=X,Time = (N-opt$days[i])/250, r = 0, b = 0,tol=0.01,maxiter=10000)}
  
  finalopt<-mutate(finalopt,ImpliedVol)
  #find minimum gamma_and_theta_terms value that is closest to zero
  min(abs(finalopt$gamma_and_theta_terms))
}

#simulate 100 runs for S=90:110 and X=90:110
for(i in 90:110){
  for(j in 1:runs){
    res[j]<-simulation1(i,i)
  }
  finalres[i]<-min(res)
}
ATM_stock_price<-c(90:110)
df_result<-cbind("ATM Stock Price"=ATM_stock_price,"Gamma & Theta"=finalres[90:110],"Implied Volatility"=ImpliedVol[1:21])
df_result
```

We can see from the dataframe results above that when Gamma and Theta neutralize each other, the implied volatility is very close to the realized volatility of 0.3.

####Simulation below to prove second point:
[2] Overall Profit and Loss "overall PnL" for the strategy is approximately equal to Vega x (Realized Vol - Implied Vol) x T.

```{r}
PnL_actual <- c(1:100)
PnL_taylor <- c(1:100)
PnL_vega <- c(1:100)
vega_term <- c(1:100)
gamma_theta <- c(1:100)
impliedVol<-vector(mode="numeric",length=23)

for (i in 1:100) {

S <- 100
X <- 100
sigma <- 0.5 # realized vol can be 0.3 for [1] or 0.5 for [2]
drift <- 0 # drift = r - q
N <- 22 # no. of trading days in a month
timestep <- 1 / 250 #in years


# ss is the simulated price movement for N days
p1 <- (drift - 0.5 * sigma * sigma) * timestep
p2 <- sigma * sqrt(timestep)
ss <- rep(S, N) * cumprod(rlnorm(N, mean = p1, sd = p2))
ss[23] <- 0
ss <- dplyr::lag(ss,n=1L)
ss[1] <- S

# create a lag vector to calculate change in stock price, dS
ss_lag <- dplyr::lag(ss, n=1L)
ss_lag[1] <- S
dS <- ss-ss_lag

# calculate option price and greeks under implied volatility
df <- data_frame(S = ss,dS=dS, days = 0:N)
opt <- mutate(df,
              opt_price = GBSOption("c", S = S, X = X, Time = (N-days) / 250, r = 0, b = 0, sigma = 0.3)@price, #calculate option price at 0.3 implied volatility
              delta = GBSGreeks("Delta", "c", S = S, X = X, Time = (N-days)/ 250, r = 0, b = 0, sigma = 0.3),
              gamma = GBSGreeks("Gamma", "c", S = S, X = X, Time = (N-days)/ 250, r = 0, b = 0, sigma = 0.3),
              vega = GBSGreeks("Vega", "c", S = S, X = X, Time = (N-days)/ 250, r = 0, b = 0, sigma = 0.3),
              theta = GBSGreeks("Theta", "c", S = S, X = X, Time = (N-days)/ 250, r = 0, b = 0, sigma = 0.3)
              )

# #back calculate implied volatility
#  for(j in 1:23){
#     impliedVol[j] <- GBSVolatility(opt$opt_price[j],"c",S=opt$S[j],X=X,Time = (N-opt$days[j])/250, r = 0, b = 0,tol=0.01,maxiter=10000)
#     }

#generate daily PnL of underlying stock position
S_position_lag <- dplyr::lag(opt$delta*-1,n=1L)
PnL_S <- S_position_lag*dS

opt <- mutate(opt,
              delta_term = dplyr::lag(opt$delta,n=1L)*dS,
              gamma_term = 0.5*dplyr::lag(opt$gamma,n=1L)*dS^2,
              #vega_term = dplyr::lag(opt$vega,n=1L)*(0.5-0.3)/250,
              theta_term = dplyr::lag(opt$theta,n=1L)/250,
              dV_taylor = dplyr::lag(opt$delta,n=1L)*dS + 0.5*dplyr::lag(opt$gamma,n=1L)*dS^2 + dplyr::lag(opt$theta,n=1L)/250,
              PnL_S = PnL_S
              #PnL_daily = PnL_opt + PnL_S
              #PnL_daily = delta*dS + 0.5*gamma*dS**2 + theta*1/250 + PnL_S
              )

PnL_actual[i] <- sum(opt$PnL_S[2:23]) + opt$opt_price[23] - opt$opt_price[1] #actual PnL of the strategy
PnL_taylor[i] <- sum(opt$dV_taylor[2:23]) + sum(opt$PnL_S[2:23]) #PnL predicted by taylor expansion approximation
vega_term[i] <- (0.5-0.3)*sum(opt$vega)*22/250 #overall PnL predicted by vega term
#gamma_theta[i] <- sum(opt$gamma_theta_terms[2:23])

result <- data_frame(PnL_actual, PnL_taylor, vega_term)

}

result <- mutate(result,
                 remainder = PnL_taylor-PnL_actual,
                 vega_err = (vega_term-PnL_actual)/PnL_actual,
                 remainder_err = (remainder-PnL_actual)/PnL_actual
                 )

datatable(result, options = list(pagelngth = 10), caption = "Comparison of actual PnL, PnL predicted by Taylor's approximation and the PnL of the overall vega term for 100 runs") %>% formatPercentage(.,columns = c("remainder_err","vega_err"),digits = 1) %>% formatRound(.,columns = c("PnL_taylor","PnL_actual","vega_term","remainder"), digits = 3)

```

From the results data frame, actual PnL and the PnL approximated by Taylor's expansion have a discrepancy which is not insignificant, as seen by the remainder term.

In theory, the PnL predicted by Taylor's expansion is:

dV = Delta * dS + 0.5* Gamma * (dS)^2 + Vega * d(Vol) + Theta * (dT) + SmallRemainder

With the PnL of the hedging strategy, PnL_S = -Delta * dS, to achieve zero delta of the strategy, the overal PnL should be:

d(PnL_overall) = dV - PnL_S = 0.5* Gamma * (dS)^2 + Vega * d(Vol) + Theta * (dT) + SmallRemainder

since the delta term cancels out. Furthermore, if the gamma and theta terms cancel out as proven in part [1], then 

d(PnL_overall) = Vega * d(Vol) + SmallRemainder

the overall PnL is left with the vega term only, consistent with the hypothsis of part [2]

However, from the simulation, the total vega term does not seem to agree with the actual PnL of the strategy. A close look at the breakdown of the taylor's approximation indicate that the gamma and theta terms do not cancel out each other, which should be the case since realized volatility and implied volatility are not equal in this simulation.
