---
title: "Week 2 Demo"
output: html_notebook
---

```{r}
bond_cf <- tibble(cf = c(5,5,5,5,105), ts = c(1,2,3,4,5)/360*30)
exp(- 0.05 * 0.0833)
bond_value <- sum(exp(- 0.05 * bond_cf$ts) * bond_cf$cf)

# add new variable/column to data frame
bond_cf$dcf <- bond_value
# or,
bond_cf["dcf"] <- bond_value
```

```{r}
# Extension from slide 120.

# Two ways 
# leave the r inside
purrr::map(1:10, function(x) { exp( - 0.05 * x) })

# place the r outside 
purrr::map(1:10, function(x,r) { exp( - r * x) }, r = 0.05)
```

```{r}
# Use purrr::map for nested loop
purrr::map(1:12, function(x) {
  purrr::map(1:5, function(y) {
    print(x+y)
  })
})
```

```{r}
# question 2 on slide 121
a <- seq(as.Date("2020-01-01"), as.Date("2020-12-01"), by = "month")

for (i in seq_along(a)) {
  print(as.character(a[i],format="%b"))
  print(as.character(a[i],format="%B"))
}
```

```{r}
# question 2 on slide 121: solution 2
# print the month names
library(lubridate)
cob <- Sys.Date()
purrr::map(1:12,function(x) {
                  month(cob) <- x
                  print(as.character(cob, format="%B"))
           })
```

```{r}
# question 3 on slide 121
# count bizdays
count_bday <- function(year, list_holidays = c()) {
  year_begin <- as.Date(paste0(year, "-01-01"))
  year_end <- as.Date(paste0(year+1, "-01-01"))
  
  cc <- 0
  cob <- year_begin
  while (cob < year_end) {
    if (weekdays(cob) %in% c("Sunday", "Saturday") || cob %in% list_holidays) {
      # do nothing      
    } else{
      cc <- cc + 1
    }
    cob <- cob + 1
  }
  cc
}

count_bday(2020)
```

If we have following sequence of releasing ten fishes.
- 1 is the fastest fish, 10 is the slowest.
- Left is first released, right is late released.

    2,5,8,10,1,4,7,6,3,9

- Fastest fish will %$# the fish ahead. First we find where `1` is.

    _,_,_,_,1,4,7,6,3,9

- Now we consider for the fish behind `1`. 
  The fastest one is `3`. The fish ahead will be #@$

    _,_,_,_,1,_,_,_,3,9

- Now we have only `9` after `3`.

    _,_,_,_,1,_,_,_,3,9
    
- This is a recursion problem.


```{r}

# generate release sequence
release_seq <- sample(1:10,10,replace=FALSE)

fish_prob <- function(rel_seq, debug = FALSE) {
  len_rel_seq <- length(rel_seq)
  fastest <- min(rel_seq)
  loc_fastest <- which(fastest == rel_seq)
  
  if (debug) {
    cat(paste0("fastest:", fastest,"\n"))
    cat(paste0("rel_seq:", paste0(rel_seq, collapse = ","),"\n"))
  }
  if (loc_fastest == len_rel_seq-1) {
    # last fish is always the survivor
    c(fastest, tail(rel_seq,1))
  } else if (loc_fastest == len_rel_seq) {
    fastest
  } else {
    c(fastest, fish_prob(rel_seq[(loc_fastest + 1):len_rel_seq]))
  }
}

release_seq <- sample(1:10,10,replace=FALSE)
# print(release_seq)
fish_prob(release_seq, debug = TRUE)

# Run a simulation of 1000 times
fish_prob_sim <- mean(sapply(1:10000, function(x) {
  release_seq <- sample(1:10,10,replace=FALSE)
  length(fish_prob(release_seq))
}))

print(fish_prob_sim)

# the analytic solution is
print(sum(rep(1,10) / 1:10))
```

## Reading a file from local.

```{r}
library(readr)
AJBU_SI <- read_csv("E:/Dropbox/MFE/FEP003/Example/2020/AJBU.SI.csv", 
    col_types = cols(Date = col_date(format = "%Y-%m-%d")))
View(AJBU_SI)
```

```{r}
## Use following four lines to practice dplyr
library(conflicted)
library(tidyverse)
conflict_prefer("lag", "dplyr")
conflict_prefer("filter", "dplyr")

library(readr)
bank <- read_delim("C:/Users/Kunlun/Downloads/bank.csv", 
                   ";", escape_double = FALSE, trim_ws = TRUE)
```

## dplyr practice

```{r}
df1 <- select(bank, age, marital)
df2 <- filter(df1, marital == "married")
max(df2$age)

unique(bank$loan)
unique(bank$housing)
unique(select(bank, housing))

filter(bank, loan == "yes" & housing == "no")

filter(bank, ! (job %in% c("unemployed", "student", "retired")))

arrange(bank, age)

arrange(bank, desc(age))

arrange(bank, desc(age), balance)

```